<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>GTX Ultimate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Force to fuck off!">
<meta property="og:type" content="website">
<meta property="og:title" content="GTX Ultimate">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="GTX Ultimate">
<meta property="og:description" content="Force to fuck off!">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GTX Ultimate">
<meta name="twitter:description" content="Force to fuck off!">
  
    <link rel="alternate" href="/atom.xml" title="GTX Ultimate" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GTX Ultimate</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你的出现亵渎了这里</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-php-code-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-4/" class="article-date">
  <time datetime="2018-03-20T09:27:37.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-4/">PHP代码实现3 [函数角度] 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p>标准函数的实现存放在ext/standard扩展目录中。</p>
<h3 id="php函数种类"><a href="#php函数种类" class="headerlink" title="php函数种类"></a>php函数种类</h3><p>Zend engine中的function的存在形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_execute_data &#123;</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    zend_function_state function_state;</span><br><span class="line">    zend_function *fbc; /* Function Being Called */</span><br><span class="line">    //...省略部分代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>zend_function 的存在形式 Union！</p>
<p>联合体的所有成员变量共享内存中的一块内存，在某个时刻只能有一个成员使用这块内存， 并且当使用某一个成员时，其仅能按照它的类型和内存大小修改对应的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zend_function &#123;</span><br><span class="line">    zend_uchar type;    /* 如用户自定义则为 #define ZEND_USER_FUNCTION 2</span><br><span class="line">                            MUST be the first element of this struct! */</span><br><span class="line"> </span><br><span class="line">    struct &#123;</span><br><span class="line">        zend_uchar type;  /* never used */</span><br><span class="line">        char *function_name;    //函数名称</span><br><span class="line">        zend_class_entry *scope; //函数所在的类作用域</span><br><span class="line">        zend_uint fn_flags;     // 作为方法时的访问类型等，如ZEND_ACC_STATIC等  </span><br><span class="line">        union _zend_function *prototype; //函数原型</span><br><span class="line">        zend_uint num_args;     //参数数目</span><br><span class="line">        zend_uint required_num_args; //需要的参数数目</span><br><span class="line">        zend_arg_info *arg_info;  //参数信息指针</span><br><span class="line">        zend_bool pass_rest_by_reference;</span><br><span class="line">        unsigned char return_reference;  //返回值 </span><br><span class="line">    &#125; common;</span><br><span class="line"> </span><br><span class="line">    zend_op_array op_array;   //函数中的操作</span><br><span class="line">    zend_internal_function internal_function;  </span><br><span class="line">&#125; zend_function;</span><br></pre></td></tr></table></figure>
<ul>
<li>在PHP的实现中，即使没有显式的返回， Zend引擎也会“帮你“返回NULL。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$func = &apos;print_r&apos;;</span><br><span class="line">$func(&apos;i am print_r function.&apos;);</span><br><span class="line"></span><br><span class="line">print_r(&apos;i am print_r function.&apos;);</span><br></pre></td></tr></table></figure>
<p>变量函数是DO_FCALL_BY_NAME，而内部函数是DO_FCALL。这在语法解析时就已经决定了</p>
<p>如果不是方法，并且不是动态调用，并且函数名为字符串常量，则其生成的中间代码为ZEND_DO_FCALL。其它情况则为ZEND_DO_FCALL_BY_NAME。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-4/" data-id="cjja5fshm000dbrm15bmhc0w1" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-3/" class="article-date">
  <time datetime="2018-03-20T05:29:59.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-3/">PHP代码实现2 [从变量和数据的角度] 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h3 id="常量的数据结构"><a href="#常量的数据结构" class="headerlink" title="常量的数据结构"></a>常量的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_constant &#123;</span><br><span class="line">    zval value; /* zval结构，PHP内部变量的存储结构，在第一小节有说明 */</span><br><span class="line">    int flags;  /* 常量的标记如 CONST_PERSISTENT | CONST_CS */</span><br><span class="line">    char *name; /* 常量名称 */</span><br><span class="line">    uint name_len;  </span><br><span class="line">    int module_number;  /* 模块号 */</span><br><span class="line">&#125; zend_constant;</span><br></pre></td></tr></table></figure>
<p>PHP对于常量的名称在定义时其实是没有所谓的限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;^_^&apos;, &apos;smile&apos;);</span><br><span class="line"> </span><br><span class="line">if (defined(&apos;^_^&apos;)) &#123;</span><br><span class="line">    echo &apos;yes&apos;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &apos;no&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//$var = ^_^;   //语法错误</span><br><span class="line">$var = constant(&quot;^_^&quot;);</span><br></pre></td></tr></table></figure>
<p>通过defined函数测试表示，^_^这个常量已经定义好，这样的常量无法直接调用， 只能使用constant()方法来获取到，否则在语法解析时会报错，因为它不是一个合法的标示符。</p>
<h3 id="常量的等级"><a href="#常量的等级" class="headerlink" title="常量的等级"></a>常量的等级</h3><p>除了CONST_CS标记，常量的flags字段通常还可以用CONST_PERSISTENT和CONST_CT_SUBST。</p>
<p>CONST_PERSISTENT表示这个常量需要持久化。这里的持久化内存申请时的持久化是一个概念， 非持久常量会在请求结束时释放该常量，如果读者还不清楚PHP的生命周期，可以参考， PHP生命周期这一小节，也就是说， [如果是非持久常量，会在RSHUTDOWN阶段就将该常量释放，否则只会在MSHUTDOWN阶段将内存释放]， 在用户空间，也就是用户定义的常量都是非持久化的，通常扩展和内核定义的常量会设置为持久化， 因为如果常量被释放了，而下次请求又需要使用这个常量，该常量就必须在请求时初始化一次， 而对于常量这些不变的量来说就是个没有意义的重复计算。</p>
<p>通过define()函数定义的常量的模块编号都是PHP_USER_CONSTANT，这表示是用户定义的常量。 除此之外我们在平时使用较多的常量：如错误报告级别E_ALL, E_WARNING等常量就有点不同了。 这些是PHP内置定义的常量，他们属于标准常量。</p>
<p>标准常量注册操作： php_module_startup() -&gt; zend_startup() -&gt; zend_register_standard_constants()]</p>
<h3 id="魔术常量-随着代码的位置而改变"><a href="#魔术常量-随着代码的位置而改变" class="headerlink" title="魔术常量 随着代码的位置而改变"></a>魔术常量 随着代码的位置而改变</h3><p>[PHP已经在词法解析时将这些常量换成了对应的值]</p>
<p>几个 PHP 的“魔术常量”<br>名称    说明<br>__LINE__    文件中的当前行号</p>
<p>__FILE__    文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，FILE 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。</p>
<p>__DIR__    文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(FILE)。除非是根目录，否则 目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）</p>
<p>__FUNCTION__    函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写&gt; 字母的</p>
<p>__CLASS__    类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的</p>
<p>__METHOD__    类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p>
<p>__NAMESPACE__    当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增）</p>
<p>前面有个比较特殊的地方，当func_name不存在时，<strong>FUNCTION</strong>被替换成空字符串， 你可能会想，怎么会有变量名不存在的方法呢，这里并不是匿名方法，匿名方法的function_name 并不是空的，而是:”{closure}”, 有兴趣的读者可以去代码找找在那里给定义了。 </p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>在PHP脚本执行的时候，用户全局变量(在用户空间显式定义的变量)会保存在一个HashTable数据类型的符号表(symbol_table)中， 而我们用得非常多的在全局范围内有效的变量却与这些用户全局变量不同。 例如:$_GET，$_POST，$_SERVER，$_FILES等变量，我们并没有在程序中定义这些变量，并且这些变量也同样保存在符号表中， 从这些表象我们不难得出结论：[PHP是在脚本运行之前就将这些特殊的变量加入到了符号表。] 在请求初始化阶段 RINIT</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="赋值左值存在引用-且左值不等于右值-MMP-这是COW-写时复制啊"><a href="#赋值左值存在引用-且左值不等于右值-MMP-这是COW-写时复制啊" class="headerlink" title="赋值左值存在引用 且左值不等于右值 MMP 这是COW 写时复制啊"></a>赋值左值存在引用 且左值不等于右值 MMP 这是COW 写时复制啊</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line"> </span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line"> </span><br><span class="line">$a = 20;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>此时Zend engine的实现行动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (PZVAL_IS_REF(variable_ptr)) &#123; // 如果is_ref_gc != 0</span><br><span class="line">    if (variable_ptr!=value) &#123; // 且右值 ！= 左值</span><br><span class="line">        zend_uint refcount = Z_REFCOUNT_P(variable_ptr); 存储refcount</span><br><span class="line"> </span><br><span class="line">        garbage = *variable_ptr;  将老值保存</span><br><span class="line">        *variable_ptr = *value;   赋予新的右值</span><br><span class="line">        Z_SET_REFCOUNT_P(variable_ptr, refcount);  设置新的refcount</span><br><span class="line">        Z_SET_ISREF_P(variable_ptr);    设置新的is ref</span><br><span class="line">        if (!is_tmp_var) &#123; </span><br><span class="line">            zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        zendi_zval_dtor(garbage);</span><br><span class="line">        return variable_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>COW介绍: 这是一种推迟内存复制带来的内存管理优化，而当变量的值发生变化时，才会进行重新开辟内存空间，这个机制我们称为写时复制机制</p>
<p>EG：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$i = 4;   //内核创建一个zval指针，并且为其以堆的方式开辟空间，让指针指向这个空间，将zval中的成员引用计数置为1，类型标记为整形，并且申请一个zvalue_value指针，同样以堆的方式以其开辟空间,同时将该联合体中的lval赋值为4,并且在symbal_table的hash表中记录变量i和zval指针的映射关系</span><br><span class="line">$j = $i;   //没有在申请内存空间，在zval的成员中引用计数标记为2</span><br><span class="line">$j = 5;   //内核重新创建zval指针，重复下上面的步骤，我就不重复说明了，重点是将旧的zval引用计数标记为1</span><br></pre></td></tr></table></figure>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，左值等于右值"><a href="#赋值的左值不存在引用，左值的引用计数为1，左值等于右值" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，左值等于右值"></a>赋值的左值不存在引用，左值的引用计数为1，左值等于右值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$a = $a; // 引用计数经历了+1 -1的过程</span><br></pre></td></tr></table></figure>
<p>Zend engine的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (Z_DELREF_P(variable_ptr)==0) &#123;  //  引用计数减一操作</span><br><span class="line">        if (!is_tmp_var) &#123;</span><br><span class="line">            if (variable_ptr==value) &#123;</span><br><span class="line">                Z_ADDREF_P(variable_ptr);   //  引用计数加一操作</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，右值存在引用"><a href="#赋值的左值不存在引用，左值的引用计数为1，右值存在引用" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，右值存在引用"></a>赋值的左值不存在引用，左值的引用计数为1，右值存在引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">$c = $a;</span><br></pre></td></tr></table></figure>
<p>这里的$c = $a;的操作就是我们所示的第三种情况。 对于这种情况，ZEND内核直接创建一个新的zval容器，左值的值为右值，并且左值的引用计数为1。 也就是说，这种情形$c不会与$a指向同一个zval。 </p>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，右值不存在引用"><a href="#赋值的左值不存在引用，左值的引用计数为1，右值不存在引用" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，右值不存在引用"></a>赋值的左值不存在引用，左值的引用计数为1，右值不存在引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$c = $a;</span><br></pre></td></tr></table></figure>
<p>这时，右值的引用计数加上，一般情况下，会对左值进行垃圾收集操作，将其移入垃圾缓冲池。垃圾缓冲池的功能是在PHP5.3后才有的。 </p>
<h4 id="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"><a href="#情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0" class="headerlink" title="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"></a>情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = $a;</span><br><span class="line">$va = 20;</span><br><span class="line">$vb = &amp;$va;</span><br><span class="line"> </span><br><span class="line">$a = $va;</span><br></pre></td></tr></table></figure>
<p>最后一个操作就是我们的情况五。 使用xdebug看引用计数发现，最终$a变量的引用计数为1，$va变量的引用计数为2，并且$va存在引用。</p>
<h3 id="变量销毁"><a href="#变量销毁" class="headerlink" title="变量销毁"></a>变量销毁</h3><p>unset()是一个语法结构， 根据变量不同出发不同的操作</p>
<p>程序会先获取目标符号表，这个符号表是一个HashTable，然后将我们需要unset掉的变量从这个HashTable中删除。 如果对HashTable的元素删除操作成功，程序还会对EX(CVs)内存储的值进行清空操作。 以缓存机制来解释，在删除原始数据后，程序也会删除相对应的缓存内容，以免用户获取到脏数据。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>对于全局变量，Zend引擎有一个_zend_executor_globals结构，该结构中的symbol_table就是全局符号表， 其中保存了在顶层作用域中的变量。</p>
<p>同样，函数或者对象的方法在被调用时会创建active_symbol_table来保存局部变量。</p>
<p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的active_symbol_table会指向当前_zend_execute_data中的symbol_table。</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ol>
<li><p>直接的变量赋值操作</p>
</li>
<li><p>运算式结果对变量的赋值操作</p>
</li>
<li><p>强制类型转换</p>
</li>
</ol>
<ul>
<li>允许进行强制类型转换的类型</li>
</ul>
<p>(int), (integer) 转换为整型</p>
<p>(bool), (boolean) 转换为布尔类型</p>
<p>(float), (double) 转换为浮点类型</p>
<p>(string) 转换为字符串</p>
<p>(array) 转换为数组</p>
<p>(object) 转换为对象</p>
<p>(unset) 转换为NULL </p>
<p>（unset）\$a(仅仅是类型转换为了null) != unset($a)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-3/" data-id="cjja5fshq000hbrm1sge4hli0" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-2/" class="article-date">
  <time datetime="2018-03-20T03:19:22.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-2/">PHP代码实现2 [从变量和数据的角度] 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&lt;编译&gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。</p>
<p>2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化</p>
<p>3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感知。</p>
<h1 id="PHP-8种变量类型"><a href="#PHP-8种变量类型" class="headerlink" title="PHP 8种变量类型"></a>PHP 8种变量类型</h1><p>String Int float Boolean Null Resource Object array</p>
<p>在官方的PHP实现内部，所有变量使用同一种数据结构(zval)来保存，而这个结构同时表示PHP中的各种数据类型。 它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。</p>
<h2 id="PHP变量存储结构"><a href="#PHP变量存储结构" class="headerlink" title="PHP变量存储结构"></a>PHP变量存储结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct zval;</span><br><span class="line">...</span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">    /* Variable information */</span><br><span class="line">    zvalue_value value;     /* value */ 变量值</span><br><span class="line">    zend_uint refcount__gc; // 引用计数 GC的时候用 默认1</span><br><span class="line">    zend_uchar type;    /* active type */ 变量类型</span><br><span class="line">    zend_uchar is_ref__gc; // 是否为引用 默认0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：在PHP5.3之后引入了新垃圾收集机制 则refcount -&gt; refcount_gc is_ref -&gt; is_ref_gc</p>
<p>【注意 变量的值存在了zvalue_value这个struct中，那么也就是其的内存占用很玄学，也就是是用union 来巧妙的避开多内存占用】</p>
<p>type:IS_NULL、IS_BOOL、IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE</p>
<h2 id="PHP变量的值的存储"><a href="#PHP变量的值的存储" class="headerlink" title="PHP变量的值的存储"></a>PHP变量的值的存储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;                  /* long value */</span><br><span class="line">    double dval;                /* double value */</span><br><span class="line">    struct &#123;						/*string value*/</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;              /* hash table value */</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>这里使用联合体而不是用结构体是出于空间利用率的考虑，因为一个变量同时只能属于一种类型。 如果使用结构体的话将会不必要的浪费空间，而PHP中的所有逻辑都围绕变量来进行的，这样的话， 内存浪费将是十分大的。这种做法成本小但收益非常大。</p>
<p>注意到字符串value中加入了int的 len， 这和MyIsam存储结构存储长度的原理是相同的，因为获取到字符串长度的时间复杂度是O(n),字符串在PHP操作中很频繁，为了节约时间开销，直接存储进来。是一种空间换时间的做法</p>
<p>【哈希相关】</p>
<p>通过合理设计的哈希函数，我们就能将key映射到合适的范围，因为我们的key空间可以很大(例如字符串key)， 在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况， 这就是我们所说的出现了冲突。 目前解决hash冲突的方法主要有两种：链接法和开放寻址法。</p>
<ul>
<li>链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。 所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表， 这样的话操作链表的时间复杂度则成了O(n)，这样哈希表的性能优势就没有了， 所以选择一个合适的哈希函数是最为关键的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket /** 采用链接法解决哈希冲突的HashTable结构 最坏情况 O(n) **/</span><br><span class="line">&#123;</span><br><span class="line">    char *key;</span><br><span class="line">    void *value;</span><br><span class="line">    struct _Bucket *next;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"> </span><br><span class="line">typedef struct _HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int elem_num;</span><br><span class="line">    Bucket** buckets;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<ul>
<li>键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。</li>
<li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。</li>
</ul>
<p>hash_Insert函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int hash_insert(HashTable *ht, char *key, void *value)</span><br><span class="line">&#123;</span><br><span class="line">    // check if we need to resize the hashtable</span><br><span class="line">    resize_hash_table_if_needed(ht);</span><br><span class="line"> </span><br><span class="line">    int index = HASH_INDEX(ht, key);</span><br><span class="line"> </span><br><span class="line">    Bucket *org_bucket = ht-&gt;buckets[index]; // 获得计算出来的index所在的bucket</span><br><span class="line">    Bucket *tmp_bucket = org_bucket;</span><br><span class="line"> </span><br><span class="line">    // check if the key-value exits already</span><br><span class="line">    while(tmp_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(key, tmp_bucket-&gt;key) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(&quot;[update]\tkey: %s\n&quot;, key);</span><br><span class="line">            tmp_bucket-&gt;value = value;</span><br><span class="line"> </span><br><span class="line">            return SUCCESS; // 查看当前的key对应的value是否已经存在了，value是不允许重复的</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tmp_bucket = tmp_bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Bucket *bucket = (Bucket *)malloc(sizeof(Bucket)); 分配新的bucket的地址</span><br><span class="line"> </span><br><span class="line">    bucket-&gt;key   = key;</span><br><span class="line">    bucket-&gt;value = value;</span><br><span class="line">    bucket-&gt;next  = NULL;  进行相关bucket的赋值</span><br><span class="line"> </span><br><span class="line">    ht-&gt;elem_num += 1;    HashTable计数增加</span><br><span class="line"> </span><br><span class="line">    if(org_bucket != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_MSG(&quot;[collision]\tindex:%d key:%s\n&quot;, index, key); 出现冲突 </span><br><span class="line">        bucket-&gt;next = org_bucket; 将新的bucket放在index的第一位 后面进行顺延</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ht-&gt;buckets[index]= bucket; </span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[insert]\tindex:%d key:%s\tht(num:%d)\n&quot;,</span><br><span class="line">        index, key, ht-&gt;elem_num);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int hash_resize(HashTable *ht)</span><br><span class="line">&#123;</span><br><span class="line">    // double the size</span><br><span class="line">    int org_size = ht-&gt;size;</span><br><span class="line">    ht-&gt;size = ht-&gt;size * 2;</span><br><span class="line">    ht-&gt;elem_num = 0; //后续重新插入，因为Double size之后 之前的冲突有可能被解开，所以重新Insert</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize]\torg size: %i\tnew size: %i\n&quot;, org_size, ht-&gt;size);</span><br><span class="line"> </span><br><span class="line">    Bucket **buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *));</span><br><span class="line"> </span><br><span class="line">    Bucket **org_buckets = ht-&gt;buckets; 获取老的buckets</span><br><span class="line">    ht-&gt;buckets = buckets;// 新的table置为空</span><br><span class="line"> </span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0; i &lt; org_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Bucket *cur = org_buckets[i];</span><br><span class="line">        Bucket *tmp;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            // rehash: insert again</span><br><span class="line">            hash_insert(ht, cur-&gt;key, cur-&gt;value);</span><br><span class="line"> </span><br><span class="line">            // free the org bucket, but not the element</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            free(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(org_buckets);</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize] done\n&quot;);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组是PHP中最常用，也是最强大变量类型，它可以存储其他类型的数据，而且提供各种内置操作函数。数组的存储相对于其他变量要复杂一些， 数组的值存储在zvalue_value.ht字段中，它是一个HashTable类型的数据。 PHP的数组使用哈希表来存储关联数据。哈希表是一种高效的键值对存储结构。PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。 PHP所有的工作都由哈希表实现，在下节HashTable中将进行哈希表基本概念的介绍以及PHP的哈希表实现。（WOC PHP竟然用HashTable存储array，O(1)!）</p>
<p>对象的存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_object_value &#123;</span><br><span class="line">    zend_object_handle handle;  //  unsigned int类型，EG(objects_store).object_buckets的索引</span><br><span class="line">    zend_object_handlers *handlers;</span><br><span class="line">&#125; zend_object_value;</span><br></pre></td></tr></table></figure>
<p>PHP的对象只有在运行时才会被创建，前面的章节介绍了EG宏，这是一个全局结构体用于保存在运行时的数据。 其中就包括了用来保存所有被创建的对象的对象池</p>
<p>而object对象值内容的zend_object_handle域就是当前 对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry，将在第五章作详细介绍</p>
<h3 id="PHP-HashTable实现"><a href="#PHP-HashTable实现" class="headerlink" title="PHP HashTable实现"></a>PHP HashTable实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _hashtable &#123; </span><br><span class="line">    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。</span><br><span class="line">    uint nTableMask;        // nTableSize-1 ， 索引取值的优化</span><br><span class="line">    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 </span><br><span class="line">    ulong nNextFreeElement; // 下一个数字索引的位置</span><br><span class="line">    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）</span><br><span class="line">    Bucket *pListHead;          // 存储数组头元素指针</span><br><span class="line">    Bucket *pListTail;          // 存储数组尾元素指针</span><br><span class="line">    Bucket **arBuckets;         // 存储hash数组</span><br><span class="line">    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放</span><br><span class="line">    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。</span><br><span class="line">    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）</span><br><span class="line">    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次</span><br><span class="line">#if ZEND_DEBUG</span><br><span class="line">    int inconsistent;</span><br><span class="line">#endif</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>PS：mask的作用就是将哈希值映射到槽位所能存储的索引范围内。 例如：某个key的索引值是21， 哈希表的大小为8，则mask为7，则求与时的二进制表示为： 10101 &amp; 111 = 101 也就是十进制的5。 因为2的整数次方-1的二进制比较特殊：后面N位的值都是1，这样比较容易能将值进行映射， 如果是普通数字进行了二进制与之后会影响哈希值的结果。那么哈希函数计算的值的平均分布就可能出现影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct bucket &#123;</span><br><span class="line">    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值</span><br><span class="line">    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0</span><br><span class="line">    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr</span><br><span class="line">    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值</span><br><span class="line">    struct bucket *pListNext;   // 整个hash表的下一元素</span><br><span class="line">    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素</span><br><span class="line">    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素</span><br><span class="line">    struct bucket *pLast;       // 同一个哈希bucket的上一个元素</span><br><span class="line">    // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体</span><br><span class="line">    char arKey[1];              // 是变长结构体 在插入的时候进行单独申请空间就可以</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>PS：如上面各字段的注释。h字段保存哈希表key哈希后的值。这里保存的哈希值而不是在哈希表中的索引值， 这是因为索引值和哈希表的容量有直接关系，如果哈希表扩容了，那么这些索引还得重新进行哈希在进行索引映射， 这也是一种优化手段。</p>
<p>在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。 所以在PHP中例如’10’，’11’这类的字符索引和数字索引10， 11没有区别。</p>
<p>HashTable的操作接口常见：</p>
<ul>
<li>初始化操作，例如zend_hash_init()函数，用于初始化哈希表接口，分配空间等。</li>
<li>查找，插入，删除和更新操作接口，这是比较常规的操作。</li>
<li>迭代和循环，这类的接口用于循环对哈希表进行操作。</li>
<li>复制，排序，倒置和销毁等操作。</li>
</ul>
<p>PS：在PHP中不管是对数组的添加操作（zend_hash_add），还是对数组的更新操作（zend_hash_update）， 其最终都是调用_zend_hash_add_or_update函数完成，这在面向对象编程中相当于两个公有方法和一个公共的私有方法的结构， 以实现一定程度上的代码复用。</p>
<h3 id="PHP-List链表实现"><a href="#PHP-List链表实现" class="headerlink" title="PHP List链表实现"></a>PHP List链表实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_llist_element &#123;</span><br><span class="line">    struct _zend_llist_element *next;</span><br><span class="line">    struct _zend_llist_element *prev;</span><br><span class="line">    char data[1]; /* Needs to always be last in the struct */</span><br><span class="line">&#125; zend_llist_element;</span><br><span class="line"> </span><br><span class="line">typedef struct _zend_llist &#123;</span><br><span class="line">    zend_llist_element *head;</span><br><span class="line">    zend_llist_element *tail;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t size;</span><br><span class="line">    llist_dtor_func_t dtor;</span><br><span class="line">    unsigned char persistent;</span><br><span class="line">    zend_llist_element *traverse_ptr;</span><br><span class="line">&#125; zend_llist;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void zend_llist_add_element(zend_llist *l, void *element) // List插入操作</span><br><span class="line">&#123;</span><br><span class="line">    zend_llist_element *tmp = pemalloc(sizeof(zend_llist_element)+l-&gt;size-1, l-&gt;persistent);</span><br><span class="line"> </span><br><span class="line">    tmp-&gt;prev = l-&gt;tail;</span><br><span class="line">    tmp-&gt;next = NULL;</span><br><span class="line">    if (l-&gt;tail) &#123;</span><br><span class="line">        l-&gt;tail-&gt;next = tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        l-&gt;head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;tail = tmp;</span><br><span class="line">    memcpy(tmp-&gt;data, element, l-&gt;size);</span><br><span class="line"> </span><br><span class="line">    ++l-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：PHP中很多的函数都会有*_ex()以及不带ex两个版本的函数，这主要是为了方便使用， 和上面的代码一样，ex版本的通常是一个功能较全或者可选参数较多的版本， 而在代码中很多地方默认的参数值都一样，为了方便使用，再封装一个普通版本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-2/" data-id="cjja5fsho000fbrm1amo67qs9" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-1/" class="article-date">
  <time datetime="2018-03-20T01:20:37.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-1/">PHP代码实现 1 [宏观角度]</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PHP-SRC-run-test-php"><a href="#PHP-SRC-run-test-php" class="headerlink" title="$PHP-SRC/run-test.php"></a>$PHP-SRC/run-test.php</h1><ul>
<li>因为如果在同一个进程中执行， 测试就会停止，后面的测试也将无法执行，php中有很多将脚本隔离的方法比如： system()，exec()等函数，这样可以使用主测试进程服务调度被测脚本和检测测试结果，通过这些外部调用执行测试。 php测试使用了proc_open()函数， 这样就可以保证测试脚本和被测试脚本之间能隔离开。</li>
</ul>
<p>如果只需要简单的进程单向进程通道 可以使用 popen</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function foo() &#123;</span><br><span class="line">    echo date(&apos;Y-m-d H:i:s&apos;).&quot;\n&quot;;</span><br><span class="line">    echo shell_exec(&apos;php -r \&apos;sleep(1); echo date(&quot;Y-m-d H:i:s&quot;).&quot; by shell_exec:blocking\n&quot;;\&apos;&apos;);       //阻塞</span><br><span class="line">    $pipe1 =  popen(&apos;php -r \&apos;sleep(2); echo date(&quot;Y-m-d H:i:s&quot;).&quot; by popen1:non-blocking\n&quot;;\&apos;&apos;, &apos;r&apos;);  //非阻塞(管道)</span><br><span class="line">    $pipe2 =  popen(&apos;php -r \&apos;sleep(1); echo date(&quot;Y-m-d H:i:s&quot;).&quot; by popen2:non-blocking\n&quot;;\&apos;&apos;, &apos;r&apos;);  //非阻塞(管道)</span><br><span class="line">    echo date(&apos;Y-m-d H:i:s&apos;).&quot;\n&quot;;</span><br><span class="line">    register_shutdown_function(function() use ($pipe1, $pipe2) &#123; //事件驱动(脚本结束事件),异步回调</span><br><span class="line">        echo stream_get_contents($pipe1); //输出子进程返回的数据</span><br><span class="line">        echo stream_get_contents($pipe2); //输出子进程返回的数据</span><br><span class="line">        pclose($pipe1);</span><br><span class="line">        pclose($pipe2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>但是如果需要双方向的功能更多的进程控制 可以使用proc_open()打开新的子进程非阻塞的执行PHP脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    $proc = proc_open(</span><br><span class="line">    //task.php 内容为 $arr = unserialize(stream_get_contents(STDIN)); $arr[&apos;time&apos;] = date(&apos;Y-m-d H:i:s&apos;, $arr[&apos;time&apos;]); echo serialize($arr);</span><br><span class="line">        &apos;/png/php/5.4.45/bin/php /home/eechen/task.php&apos;,</span><br><span class="line">        array(</span><br><span class="line">            0 =&gt; array(&apos;pipe&apos;,&apos;r&apos;), //stdin (用fwrite写入数据给管道)</span><br><span class="line">            1 =&gt; array(&apos;pipe&apos;,&apos;w&apos;), //stdout(用stream_get_contents获取管道输出)</span><br><span class="line">            2 =&gt; array(&apos;pipe&apos;,&apos;w&apos;), //stderr(用stream_get_contents获取管道输出)</span><br><span class="line">            //2 =&gt; array(&apos;file&apos;,&apos;/tmp/err.txt&apos;,&apos;a&apos;) //stderr(写入到文件)</span><br><span class="line">        ),</span><br><span class="line">        $pipes, //管道(stdin/stdout/stderr)</span><br><span class="line">        &apos;/tmp&apos;, //当前PHP进程的工作目录</span><br><span class="line">        array(&apos;foo&apos; =&gt; &apos;bar&apos;) //php.ini 配置 variables_order = &quot;EGPCS&quot; 其中E表示$_ENV,否则$_ENV输出为空 要执行脚本所需要的环境变量</span><br><span class="line">    );</span><br><span class="line">    //var_dump($pipes); //resource of type (stream)</span><br><span class="line">    if(is_resource($proc)) &#123;</span><br><span class="line">        //stdin</span><br><span class="line">        $stdin = serialize(array(&apos;time&apos; =&gt; time()));</span><br><span class="line">        fwrite($pipes[0], $stdin); //把参数传给脚本task.php</span><br><span class="line">        fclose($pipes[0]); //fclose关闭管道后proc_close才能退出子进程,否则会发生死锁</span><br><span class="line">        register_shutdown_function(function() use($pipes, $proc) &#123; //事件驱动(脚本结束事件),异步回调</span><br><span class="line">            //stdout</span><br><span class="line">            $stdout = stream_get_contents($pipes[1]);</span><br><span class="line">            fclose($pipes[1]);</span><br><span class="line">            //stderr</span><br><span class="line">            $stderr = stream_get_contents($pipes[2]);</span><br><span class="line">            fclose($pipes[2]);</span><br><span class="line">            //exit code (返回进程的终止状态码,如果发生错则返回-1)</span><br><span class="line">            $status = proc_close($proc);</span><br><span class="line">            $data = array(</span><br><span class="line">                &apos;stdout&apos; =&gt; $stdout,</span><br><span class="line">                &apos;stderr&apos; =&gt; $stderr,</span><br><span class="line">                &apos;status&apos; =&gt; $status,</span><br><span class="line">            );</span><br><span class="line">            var_export($data); //echo json_encode($data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<h1 id="宏定义-C"><a href="#宏定义-C" class="headerlink" title="宏定义 C"></a>宏定义 C</h1><p>PHP代码中的宏定义包含 # 和 ##</p>
<p>‘##’代表 连接符 用来把两个语言符号(Token)组合成单个语言符号。 这里的语言符号不一定是宏的变量。并且双井号不能作为第一个或最后一个元素存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define PHP_FUNCTION            ZEND_FUNCTION</span><br><span class="line">#define ZEND_FUNCTION(name)             ZEND_NAMED_FUNCTION(ZEND_FN(name))</span><br><span class="line">#define ZEND_FN(name) zif_##name</span><br><span class="line">#define ZEND_NAMED_FUNCTION(name)       void name(INTERNAL_FUNCTION_PARAMETERS)</span><br><span class="line">#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, \</span><br></pre></td></tr></table></figure>
<p>“#”是一种预处理运算符，它的功能是将其后面的宏参数进行 字符串化操作</p>
<h1 id="PHP中代码的do-while宏"><a href="#PHP中代码的do-while宏" class="headerlink" title="PHP中代码的do-while宏"></a>PHP中代码的do-while宏</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define ALLOC_ZVAL(z)                                   \</span><br><span class="line">do &#123;                                                \</span><br><span class="line">    (z) = (zval*)emalloc(sizeof(zval_gc_info));     \</span><br><span class="line">    GC_ZVAL_INIT(z);                                \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure>
<p>显而易见代码只执行一次，常用用例举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define TEST(a, b)  a++;b++;</span><br><span class="line"> </span><br><span class="line">if (expr)</span><br><span class="line">    TEST(a, b);</span><br><span class="line">else</span><br><span class="line">    do_else();</span><br></pre></td></tr></table></figure>
<p>如果直接编译会造成if 后面的单句规则被破坏。</p>
<p>以及需要考虑到平台移植，空操作也使用 do{}while(0)来进行宏定义</p>
<h1 id="PHP运行时的全局参数-PHP-CORE-GLOBALS"><a href="#PHP运行时的全局参数-PHP-CORE-GLOBALS" class="headerlink" title="PHP运行时的全局参数 PHP CORE GLOBALS"></a>PHP运行时的全局参数 PHP<em> CORE</em> GLOBALS</h1><p>首先会根据ZTS 或者NTS （线程安全） 来有一些变化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">struct _php_core_globals &#123;</span><br><span class="line">        zend_bool magic_quotes_gpc; //  是否对输入的GET/POST/Cookie数据使用自动字符串转义。</span><br><span class="line">        zend_bool magic_quotes_runtime; //是否对运行时从外部资源产生的数据使用自动字符串转义</span><br><span class="line">        zend_bool magic_quotes_sybase;  //   是否采用Sybase形式的自动字符串转义</span><br><span class="line"> </span><br><span class="line">        zend_bool safe_mode;    //  是否启用安全模式</span><br><span class="line"> </span><br><span class="line">        zend_bool allow_call_time_pass_reference;   //是否强迫在函数调用时按引用传递参数 引用传值 值复制传值</span><br><span class="line">        zend_bool implicit_flush;   //是否要求PHP输出层在每个输出块之后自动刷新数据</span><br><span class="line"> </span><br><span class="line">        long output_buffering;  //输出缓冲区大小(字节)</span><br><span class="line"> </span><br><span class="line">        char *safe_mode_include_dir;    //在安全模式下，该组目录和其子目录下的文件被包含时，将跳过UID/GID检查。</span><br><span class="line">        zend_bool safe_mode_gid;    //在安全模式下，默认在访问文件时会做UID比较检查</span><br><span class="line">        zend_bool sql_safe_mode;</span><br><span class="line">        zend_bool enable_dl;    //是否允许使用dl()函数。dl()函数仅在将PHP作为apache模块安装时才有效。</span><br><span class="line"> </span><br><span class="line">        char *output_handler;   // 将所有脚本的输出重定向到一个输出处理函数。</span><br><span class="line"> </span><br><span class="line">        char *unserialize_callback_func;    // 如果解序列化处理器需要实例化一个未定义的类，这里指定的回调函数将以该未定义类的名字作为参数被unserialize()调用，</span><br><span class="line">        long serialize_precision;   //将浮点型和双精度型数据序列化存储时的精度(有效位数)。</span><br><span class="line"> </span><br><span class="line">        char *safe_mode_exec_dir;   //在安全模式下，只有该目录下的可执行程序才允许被执行系统程序的函数执行。</span><br><span class="line"> </span><br><span class="line">        long memory_limit;  //一个脚本所能够申请到的最大内存字节数(可以使用K和M作为单位)。</span><br><span class="line">        long max_input_time;    // 每个脚本解析输入数据(POST, GET, upload)的最大允许时间(秒)。</span><br><span class="line"> </span><br><span class="line">        zend_bool track_errors; //是否在变量$php_errormsg中保存最近一个错误或警告消息。</span><br><span class="line">        zend_bool display_errors;   //是否将错误信息作为输出的一部分显示。</span><br><span class="line">        zend_bool display_startup_errors;   //是否显示PHP启动时的错误。</span><br><span class="line">        zend_bool log_errors;   // 是否在日志文件里记录错误，具体在哪里记录取决于error_log指令</span><br><span class="line">        long      log_errors_max_len;   //设置错误日志中附加的与错误信息相关联的错误源的最大长度。</span><br><span class="line">        zend_bool ignore_repeated_errors;   //   记录错误日志时是否忽略重复的错误信息。</span><br><span class="line">        zend_bool ignore_repeated_source;   //是否在忽略重复的错误信息时忽略重复的错误源。</span><br><span class="line">        zend_bool report_memleaks;  //是否报告内存泄漏。</span><br><span class="line">        char *error_log;    //将错误日志记录到哪个文件中。</span><br><span class="line"> </span><br><span class="line">        char *doc_root; //PHP的”根目录”。</span><br><span class="line">        char *user_dir; //告诉php在使用 /~username 打开脚本时到哪个目录下去找</span><br><span class="line">        char *include_path; //指定一组目录用于require(), include(), fopen_with_path()函数寻找文件。</span><br><span class="line">        char *open_basedir; // 将PHP允许操作的所有文件(包括文件自身)都限制在此组目录列表下。</span><br><span class="line">        char *extension_dir;    //存放扩展库(模块)的目录，也就是PHP用来寻找动态扩展模块的目录。</span><br><span class="line"> </span><br><span class="line">        char *upload_tmp_dir;   // 文件上传时存放文件的临时目录</span><br><span class="line">        long upload_max_filesize;   // 允许上传的文件的最大尺寸。</span><br><span class="line"> </span><br><span class="line">        char *error_append_string;  // 用于错误信息后输出的字符串</span><br><span class="line">        char *error_prepend_string; //用于错误信息前输出的字符串</span><br><span class="line"> </span><br><span class="line">        char *auto_prepend_file;    //指定在主文件之前自动解析的文件名。</span><br><span class="line">        char *auto_append_file; //指定在主文件之后自动解析的文件名。</span><br><span class="line"> </span><br><span class="line">        arg_separators arg_separator;   //PHP所产生的URL中用来分隔参数的分隔符。</span><br><span class="line"> </span><br><span class="line">        char *variables_order;  // PHP注册 Environment, GET, POST, Cookie, Server 变量的顺序。</span><br><span class="line"> </span><br><span class="line">        HashTable rfc1867_protected_variables;  //  RFC1867保护的变量名，在main/rfc1867.c文件中有用到此变量</span><br><span class="line"> </span><br><span class="line">        short connection_status;    //  连接状态，有三个状态，正常，中断，超时</span><br><span class="line">        short ignore_user_abort;    //  是否即使在用户中止请求后也坚持完成整个请求。</span><br><span class="line"> </span><br><span class="line">        unsigned char header_is_being_sent; //  是否头信息正在发送</span><br><span class="line"> </span><br><span class="line">        zend_llist tick_functions;  //  仅在main目录下的php_ticks.c文件中有用到，此处定义的函数在register_tick_function等函数中有用到。</span><br><span class="line"> </span><br><span class="line">        zval *http_globals[6];  // 存放GET、POST、SERVER等信息</span><br><span class="line"> </span><br><span class="line">        zend_bool expose_php;   //  是否展示php的信息</span><br><span class="line"> </span><br><span class="line">        zend_bool register_globals; //  是否将 E, G, P, C, S 变量注册为全局变量。</span><br><span class="line">        zend_bool register_long_arrays; //   是否启用旧式的长式数组(HTTP_*_VARS)。</span><br><span class="line">        zend_bool register_argc_argv;   //  是否声明$argv和$argc全局变量(包含用GET方法的信息)。</span><br><span class="line">        zend_bool auto_globals_jit; //  是否仅在使用到$_SERVER和$_ENV变量时才创建(而不是在脚本一启动时就自动创建)。</span><br><span class="line"> </span><br><span class="line">        zend_bool y2k_compliance;   //是否强制打开2000年适应(可能在非Y2K适应的浏览器中导致问题)。</span><br><span class="line"> </span><br><span class="line">        char *docref_root;  // 如果打开了html_errors指令，PHP将会在出错信息上显示超连接，</span><br><span class="line">        char *docref_ext;   //指定文件的扩展名(必须含有’.&apos;)。</span><br><span class="line"> </span><br><span class="line">        zend_bool html_errors;  //是否在出错信息中使用HTML标记。</span><br><span class="line">        zend_bool xmlrpc_errors;   </span><br><span class="line"> </span><br><span class="line">        long xmlrpc_error_number;</span><br><span class="line"> </span><br><span class="line">        zend_bool activated_auto_globals[8];</span><br><span class="line"> </span><br><span class="line">        zend_bool modules_activated;    //  是否已经激活模块</span><br><span class="line">        zend_bool file_uploads; //是否允许HTTP文件上传。</span><br><span class="line">        zend_bool during_request_startup;   //是否在请求初始化过程中</span><br><span class="line">        zend_bool allow_url_fopen;  //是否允许打开远程文件</span><br><span class="line">        zend_bool always_populate_raw_post_data;    //是否总是生成$HTTP_RAW_POST_DATA变量(原始POST数据)。</span><br><span class="line">        zend_bool report_zend_debug;    //  是否打开zend debug，仅在main/main.c文件中有使用。</span><br><span class="line"> </span><br><span class="line">        int last_error_type;    //  最后的错误类型</span><br><span class="line">        char *last_error_message;   //  最后的错误信息</span><br><span class="line">        char *last_error_file;  //  最后的错误文件</span><br><span class="line">        int  last_error_lineno; //  最后的错误行</span><br><span class="line"> </span><br><span class="line">        char *disable_functions;    //该指令接受一个用逗号分隔的函数名列表，以禁用特定的函数。</span><br><span class="line">        char *disable_classes;  //该指令接受一个用逗号分隔的类名列表，以禁用特定的类。</span><br><span class="line">        zend_bool allow_url_include;    //是否允许include/require远程文件。</span><br><span class="line">        zend_bool exit_on_timeout;  //  超时则退出</span><br><span class="line">#ifdef PHP_WIN32</span><br><span class="line">        zend_bool com_initialized;</span><br><span class="line">#endif</span><br><span class="line">        long max_input_nesting_level;   //最大的嵌套层数</span><br><span class="line">        zend_bool in_user_include;  //是否在用户包含空间</span><br><span class="line"> </span><br><span class="line">        char *user_ini_filename;    //  用户的ini文件名</span><br><span class="line">        long user_ini_cache_ttl;    //  ini缓存过期限制</span><br><span class="line"> </span><br><span class="line">        char *request_order;    //  优先级比variables_order高，在request变量生成时用到，个人觉得是历史遗留问题</span><br><span class="line"> </span><br><span class="line">        zend_bool mail_x_header;    //  仅在ext/standard/mail.c文件中使用，</span><br><span class="line">        char *mail_log;</span><br><span class="line"> </span><br><span class="line">        zend_bool in_error_log;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="PHP-生命周期"><a href="#PHP-生命周期" class="headerlink" title="PHP 生命周期"></a>PHP 生命周期</h1><p>PHPINIT 调用模块前的初始化：</p>
<p>初始化若干全局变量 大都设置为NULL</p>
<p>初始化若干常量 PHP_Version等</p>
<p>初始化zend Engine 和 核心组件</p>
<ul>
<li>包括内存管理初始化、 全局使用的函数指针初始化（如前面所说的zend_printf等），对PHP源文件进行词法分析、语法分析、 中间代码执行的函数指针的赋值，初始化若干HashTable（比如函数表，常量表等等），为ini文件解析做准备， 为PHP源文件解析做准备，注册内置函数（如strlen、define等），注册标准常量（如E_ALL、TRUE、NULL等）、注册GLOBALS全局变量等。</li>
</ul>
<p>解析PHPini到PHP core globals</p>
<p>全局操作函数初始化</p>
<p>初始化静态构建的模块和共享模块MINIT 模块初始化 扩展模块的函数初始化 注册常量 定义模块的使用 Web Server启动或者脚本开始执行</p>
<ul>
<li>通过php_register_internal_extensions_func函数用来注册静态构建的模块，也就是默认加载的模块， 我们可以将其认为内置模块</li>
</ul>
<p>RINIT 模块激活阶段 开始使用模块</p>
<p>解析</p>
<p>RSHUTDOWN 停用模块 </p>
<p>MSHUTDOWN WebServer关闭或者脚本停止使用</p>
<h1 id="关于扩展重用"><a href="#关于扩展重用" class="headerlink" title="关于扩展重用"></a>关于扩展重用</h1><p>因为PHP的实现是和zend引擎实现紧耦合，所以PHP的扩展并不具有很好的移植性，比如移植到JVM虚拟机，移植到HHVM等，如果实现解耦合，那么扩展的重用将会容易。</p>
<h1 id="PHP的运行模式"><a href="#PHP的运行模式" class="headerlink" title="PHP的运行模式"></a>PHP的运行模式</h1><p>FastCGI、CGI、SAPI模块形式、嵌入式</p>
<p>SAPI:Server Application Program Interface</p>
<p>CGI：“通用网关接口”(Common Gateway Interface)</p>
<p>FastCGI：long-live 常驻内存型升级版高性能CGI 防止CGI的fork-and-execute模式。</p>
<h1 id="PHP脚本运行"><a href="#PHP脚本运行" class="headerlink" title="PHP脚本运行"></a>PHP脚本运行</h1><p>目前编程语言可以分为两大类:</p>
<ul>
<li><p>第一类是像C/C++， .NET， Java之类的编译型语言， 它们的共性是: 运行之前必须对源代码进行编译，然后运行编译后的目标文件。</p>
</li>
<li><p>第二类比如:PHP， Javascript， Ruby， Python这些解释型语言， 他们都无需经过编译即可”运行”，虽然可以理解为直接运行，</p>
</li>
</ul>
<p>PHP完成基本准备工作</p>
<p>启动PHP以及Zend引擎</p>
<p>加载注册扩展模块</p>
<p>Zend引擎进行 </p>
<p>lex生成的 词法分析：将代码转换为一个个标记token </p>
<ul>
<li>很多编程语言都使用lex/yacc或他们的变体(flex/bison)来作为语言的词法语法分析生成器</li>
</ul>
<p>语法分析 bison生成 语法分析器</p>
<p>转换为opcode</p>
<h4 id="opcode结构体"><a href="#opcode结构体" class="headerlink" title="opcode结构体"></a>opcode结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_op &#123; // 这里是struct实现</span><br><span class="line">    opcode_handler_t handler; // 执行该opcode时调用的处理函数</span><br><span class="line">    znode result;</span><br><span class="line">    znode op1;</span><br><span class="line">    znode op2;</span><br><span class="line">    ulong extended_value; // 脚本执行时候需要的其他信息</span><br><span class="line">    uint lineno;</span><br><span class="line">    zend_uchar opcode;  // opcode代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数是在编译器遇到echo语句的时候进行编译的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void zend_do_echo(const znode *arg TSRMLS_DC) &#123;</span><br><span class="line">    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);</span><br><span class="line">     </span><br><span class="line">    opline-&gt;opcode = ZEND_ECHO;</span><br><span class="line">    </span><br><span class="line">    opline-&gt;op1 = *arg;</span><br><span class="line">    </span><br><span class="line">    SET_UNUSED(opline-&gt;op2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器遇到print语句的时候进行编译的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void zend_do_print(znode *result，const znode *arg TSRMLS_DC) &#123;</span><br><span class="line">    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);</span><br><span class="line"> </span><br><span class="line">    opline-&gt;result.op_type = IS_TMP_VAR;</span><br><span class="line">    </span><br><span class="line">    opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));</span><br><span class="line">    </span><br><span class="line">    opline-&gt;opcode = ZEND_PRINT;</span><br><span class="line">    </span><br><span class="line">    opline-&gt;op1 = *arg;</span><br><span class="line">    </span><br><span class="line">    SET_UNUSED(opline-&gt;op2);</span><br><span class="line">    </span><br><span class="line">    *result = opline-&gt;result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【这里可以看到print和echo的根本区别 print有返回值 echo并没有 两者都是语法结构，返回null也是有返回值！】</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-1/" data-id="cjja5fshn000ebrm12e2ahpxb" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ncre47" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/ncre47/" class="article-date">
  <time datetime="2018-03-19T15:25:06.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/ncre47/">计算机四级-网络工程 Day7</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li><p>组成计算机各类资源中 主要包含 硬件 代码 数据</p>
</li>
<li><p>硬盘可以做到实时同时共享</p>
</li>
<li><p>多道程序使得程序能够并发运行，相比单通道程序 不再具有可再现性</p>
</li>
<li><p>每个订票点服务器上发送订票进程相互的关系是互斥关系</p>
</li>
<li><p>在对临界资源访问前，必须调用进入区代码</p>
</li>
<li><p>逻辑地址转换为内存物理地址的过程为 重定位</p>
</li>
<li><p>将驻留在内存中最长的页面调出的策略是FIFO</p>
</li>
<li><p>逻辑上连续的文件信息依次存放在连续编号的磁盘块中 顺序结构</p>
</li>
<li><p>适合随机访问并且易于文件扩展的  索引结构</p>
</li>
<li><p>第七套 23 - 25题目注意看一下</p>
</li>
<li><p>设置设备管理的功能主要目的是方便用户使用</p>
</li>
<li><p>资源有序分配法 是死锁的预防</p>
</li>
<li><p>30题目看一下</p>
</li>
<li><p>研究操作系统的观点 软件、资源管理、进程、虚拟机、服务提供者</p>
</li>
<li><p>进程生命状态 就绪状态 运行状态 等待状态</p>
</li>
<li><p>相互并发引发的问题 同步问题 互斥问题 死锁问题 饥饿问题</p>
</li>
<li><p>固定分区 可变分区可以为进程分配一组连续的单元</p>
</li>
<li><p>虚拟页式存储方案中 当判断页面是否调入内存 驻留位 有效位 存在位 中断位</p>
</li>
<li><p>文件分为 普通文件 目录文件 特殊文件</p>
</li>
<li><p>IO硬件包含 适配器和接口部件 设备控制器 设备硬件</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li><p>OSI 提供路由选择功能层次 网络层</p>
</li>
<li><p>CSMA\CD 第一步是侦听总线</p>
</li>
<li><p>千兆以太网 和普通的Ethernet的帧结构是一样的</p>
</li>
<li><p>局域网交换机 核心技术是 端口 Mac地址映射</p>
</li>
<li><p>42题目的根据子网掩码判断在同一个子网看一下</p>
</li>
<li><p>IP数据报投长度以32b为单位 </p>
</li>
<li><p>IP组播中 非IP组播成员也可以发送消息</p>
</li>
<li><p>Internet层次命名机制 名字空间 是树形的</p>
</li>
<li><p>浏览器组成 控制单元 客户单元 解释单元</p>
</li>
<li><p>IM中 音频聊天采用UDP  应用共享 比如白板 采用的是TCP</p>
</li>
<li><p>Sun- NFS</p>
</li>
<li><p>Bittorrent采用MIT开源的系统 最初没有DHT</p>
</li>
<li><p>CMIP  轮询中断 trap 事件报告采用 ROP方式</p>
</li>
<li><p>Ethernet 前导码 7b 原地址可以使用IP地址 Mac地址 物理地址 数据字段最短46 类型字段支出网络层协议类型</p>
</li>
<li><p>VLAN不可以用集线器进行组件 可以基于组播、IP、Mac、交换机</p>
</li>
<li><p>IP的特点 隐藏了低层次的网络细节 不指定网络互连的拓扑结构 同一的地址描述方法 不要求网络之间全互连</p>
</li>
<li><p>浏览器安全 要求站点来传证书 防止第三方偷看可以用SSL</p>
</li>
<li><p>P2P基于小世界 六度理论假设</p>
</li>
<li><p>Des 每轮操作都有置换和代还 最后一轮迭代输出64bit 56位秘钥长度</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/19/ncre47/" data-id="cjja5fshk000bbrm1b05qkgwv" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-interview-xiaomi" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/interview-xiaomi/" class="article-date">
  <time datetime="2018-03-19T13:39:46.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/interview-xiaomi/">XiaoMi Interview Log</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h1><ul>
<li><p>PHP 弱类型 实现？</p>
</li>
<li><p>COW 写时复制 实现？ COW的时候内存的变化</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = $b = 1;</span><br><span class="line">$b = 2; 的内存变化 ?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提供一个rand()函数【函数输出0 - 正无穷】 想方设法实现rand(min, max)</p>
</li>
<li><p>Eureka Server 服务怎么实现</p>
</li>
<li><p>MySQL的InnoDB事务等级</p>
</li>
<li><p>HTTP协议分为几种组成部分</p>
</li>
<li><p>Zend Engine 的实现</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/19/interview-xiaomi/" data-id="cjja5fshb0004brm1od5f9u96" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-eight" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/15/eight/" class="article-date">
  <time datetime="2018-03-15T14:56:11.000Z" itemprop="datePublished">2018-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/15/eight/">八皇后问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#八皇后问题</p>
<h3 id="依然是递归-看和之前shooting的代码很像"><a href="#依然是递归-看和之前shooting的代码很像" class="headerlink" title="依然是递归 看和之前shooting的代码很像"></a>依然是递归 看和之前shooting的代码很像</h3><h3 id="根据上述描述，我们可以得到如果两个皇后Q1-x-y-和Q2-row-col-不符合要求，则以下四个条件之一必符合。"><a href="#根据上述描述，我们可以得到如果两个皇后Q1-x-y-和Q2-row-col-不符合要求，则以下四个条件之一必符合。" class="headerlink" title="根据上述描述，我们可以得到如果两个皇后Q1(x, y)和Q2(row, col)不符合要求，则以下四个条件之一必符合。"></a>根据上述描述，我们可以得到如果两个皇后Q1(x, y)和Q2(row, col)不符合要求，则以下四个条件之一必符合。</h3><ul>
<li><p>x == row</p>
</li>
<li><p>y == col</p>
</li>
<li><p>x + y == row + col （斜向正方向）</p>
</li>
<li><p>x - y == row - col（斜向反方向）</p>
</li>
</ul>
<p>8个皇后都找到了安全位置代表棋局的成功，用一个长度为8的整数数组colume代表成功摆放的8个皇后.</p>
<p>[数组索引代表棋盘的col向量，而数组的值为棋盘的row向量，所以(row,col)的皇后可以表示为(colume[col],col)]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">#define QUEEN_NUM 8</span><br><span class="line">int ResultCounter = 0;</span><br><span class="line"></span><br><span class="line">void printResult(int colume[]);</span><br><span class="line">bool check(int colume[], int col);</span><br><span class="line">void QueenSolution(int colume[], int col);</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    //数组colume中存放的是行值</span><br><span class="line">    //即假设col[0]==3，表明第1列中皇后在第4行上</span><br><span class="line">    int colume[QUEEN_NUM] = &#123;0&#125;;</span><br><span class="line">    QueenSolution(colume, 0);</span><br><span class="line">    std::cout &lt;&lt; &quot;Solution Total Count: &quot; &lt;&lt; ResultCounter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出数组中的一组结果</span><br><span class="line">void printResult(int colume[])&#123;</span><br><span class="line">    for(int i = 0; i &lt; QUEEN_NUM; i++)</span><br><span class="line">        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; colume[i] &lt;&lt; &quot;, &quot; &lt;&lt; i &lt;&lt; &quot;) &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    ResultCounter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检查当前列col，在现有情况下，能否放置皇后</span><br><span class="line">//如果是以下四种情况，就返回false</span><br><span class="line">//1）x=row(在纵向不能有两个皇后)</span><br><span class="line">//2)  y=col（横向）</span><br><span class="line">//3）col + row = y+x;（斜向正方向）</span><br><span class="line">//4)  col - row = y-x;（斜向反方向）</span><br><span class="line">bool check(int colume[], int col)&#123;</span><br><span class="line">    //因为提供的是列信息，我们就逐列进行检查</span><br><span class="line">    for(int i = 0; i &lt; col; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(colume[i] == colume[col] ||</span><br><span class="line">           std::abs(colume[i] - colume[col]) == col - i )</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//尝试第col列上的所有解</span><br><span class="line">//即在第col列的所有行上依次检验</span><br><span class="line">//调用此函数时，表明从第0列到第col-1列都已经安置好了皇后</span><br><span class="line">void QueenSolution(int colume[], int col)&#123;</span><br><span class="line">    if(col == QUEEN_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">        printResult(colume);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //新的一列中，皇后有可能在 任意 一行</span><br><span class="line">    for(int i = 0; i &lt; QUEEN_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        colume[col] = i;  //将这个皇后放在第i行，进行检查</span><br><span class="line">        if( check(colume, col) )</span><br><span class="line">            QueenSolution(colume, col+1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/15/eight/" data-id="cjja5fsha0003brm1zk5b2sdf" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-shooting" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/15/shooting/" class="article-date">
  <time datetime="2018-03-15T10:54:02.000Z" itemprop="datePublished">2018-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/15/shooting/">打靶训练</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个射击运动员打靶，靶一共有10环，连开10枪打中90环的情况有多少种？需要考虑10枪的先后关系，比如9环10环同10环9环是不同的。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可以直接暴力十个for 在最后一个for里面判断 空间和时间复杂度都太大了</p>
</li>
<li><p>使用递归的方式 减少空间复杂度</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int sum;</span><br><span class="line">int store[10];</span><br><span class="line">void Output()          //打印</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=9;i&gt;=0;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;store[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    ++sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Comput(int score, int num)</span><br><span class="line">&#123;</span><br><span class="line">    if(score&lt;0 || score&gt;(num+1)*10)       // 前者是因为已经打满了90环 在Comput的第一个参数有个减法 后者是不可能打满90环</span><br><span class="line">        return ;</span><br><span class="line">    if(num==0)                  //打到最后一次 直接将剩下的环数进行匹配 这样避免了最后一次的for循环</span><br><span class="line">    &#123;</span><br><span class="line">        store[num]=score;</span><br><span class="line">        Output();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;=10;i++)                 //没有出现上述情况，递归</span><br><span class="line">    &#123;</span><br><span class="line">        store[num]=i;                       // 这一发打了多少环 0-10环循环</span><br><span class="line">        Comput(score-i,num-1);              // 下一发应该打的目的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Comput(90,9);</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样就理解了！</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/15/shooting/" data-id="cjja5fshr000ibrm18qv48q6a" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ncre46" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/14/ncre46/" class="article-date">
  <time datetime="2018-03-14T02:19:06.000Z" itemprop="datePublished">2018-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/14/ncre46/">计算机四级-网络工程 Day6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li><p>配置操作系统的目的是提高计算机系统资源的利用率</p>
</li>
<li><p>使进程从阻塞态转换为挂起的原语是 suspend</p>
</li>
<li><p>pthread_mutex_init() 表示创建一个互斥量 pthread_mutex_unlock表示释放一个互斥量</p>
</li>
<li><p>直接通信中  系统提供的发送原语是 send(receiver, message)</p>
</li>
<li><p>源代码-》 编译 -》目标文件.obj -》 链接 -》 可执行文件exe</p>
</li>
<li><p>进程交换是指将暂时不用的进程代码、数据等交换到磁盘</p>
</li>
<li><p>cpu 3% 磁盘 97% 此时磁盘较忙 cpu大部分资源都给了硬盘</p>
</li>
<li><p>为了提高内存利用率 可以根据需要采用多种不同大小的页面</p>
</li>
<li><p>时间局部性 大量循环 空间局部性 程序代码的顺序性</p>
</li>
<li><p>多级树形目录 复杂化了文件管理 对于用户来说 解决了文件重名的问题</p>
</li>
<li><p>最适合磁带的文件物理结构是 顺序结构</p>
</li>
<li><p>第六套23题了解一下 </p>
</li>
</ul>
<p>柱面号=逻辑块号 / （每个柱面扇区数 * 磁盘结构盘面数） </p>
<p>磁头号=逻辑块号 mod （每个柱面扇区数 * 磁盘结构盘面数） / 扇区数</p>
<p>扇区号=逻辑块号 mod （每个柱面扇区数 * 磁盘结构盘面数）mod 扇区数</p>
<ul>
<li><p>第六套25题了解一下</p>
</li>
<li><p>键盘控制方式采用中断方式</p>
</li>
<li><p>设备独立层的作用 屏蔽IO设备驱动多样性 </p>
</li>
<li><p>进程控制块必须常驻内存</p>
</li>
<li><p>信号量初始化之后 只能实施PV原语操作</p>
</li>
<li><p>引入虚拟页式存储管理系统 会出现  页面都懂 belady异常 缺页中断  页面写错误</p>
</li>
<li><p>文件控制块：文件大小 文件创建时间 文件拥有者 文件访问权限</p>
</li>
<li><p>Spooling系统主要组成成分 输入井和输出井 输入缓冲区和输出缓冲区  输入进程和输出进程</p>
</li>
<li><p>死锁产生条件 进程推进不当 资源分配不当 产生环路是死锁的必要条件</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li><p>计算机网络是联网的自制计算机集合</p>
</li>
<li><p>EtherNet以太网数据帧长度最大1500B  64-1518B</p>
</li>
<li><p>跳频扩频可以使用2.4Ghz的ISM频段</p>
</li>
<li><p>CSMA/CA是一种介质访问控制方法 重发之前需要等待一段时间</p>
</li>
<li><p>IP 不靠谱 面向无连接 尽最大努力</p>
</li>
<li><p>多设备用一个IP NAT设备应该采用的工作模式 NAPT</p>
</li>
<li><p>POP3发送协议中 STAT查询报文总数和长度 PETR请求服务器发送指定编号的邮件 QUIT删除指定邮件</p>
</li>
<li><p>P2P网络：</p>
</li>
</ul>
<p>集中式、分布式结构化、分布式非结构化、混合式</p>
<p>集中式服务器存储目录和索引信息</p>
<p>分布式非结构化网络通常使用完全随机图 </p>
<p>分布式结构化网络通常采用分布式散列表</p>
<ul>
<li>SIP</li>
</ul>
<p>消息通常分为2类 </p>
<p>起始行分为请求行和状态行</p>
<p>消息头和消息体通过CRLF分割</p>
<p>请求消息分为6中类型</p>
<p>只有发送方发送Invite</p>
<ul>
<li>XMPP</li>
</ul>
<p>实体地址称为JID</p>
<ul>
<li>NetBIOS协议 </li>
</ul>
<p>名称15字符 </p>
<p>话路数量 254</p>
<p>4种SMB</p>
<ul>
<li>SNMP</li>
</ul>
<p>类似一个CMIS 轮询 中断 trap</p>
<p>CMIP 终端用户负担轻</p>
<ul>
<li>802.11帧结构 </li>
</ul>
<p>帧控制字段长度2字节</p>
<p>数据部分长度可变</p>
<p>采用CRC效验</p>
<ul>
<li><p>IPV6注意事项：先导0可以省略 后导0不可以省略</p>
</li>
<li><p>服务器相应并发请求可以使用并发服务器或者重复服务器方案</p>
</li>
<li><p>Web服务采用CS BS工作模式</p>
</li>
<li><p>C1级别描述 数据保护以用户组为单位 用户和数据分离 比C2安全性低</p>
</li>
</ul>
<p>橘皮书安全等级：桔皮书将计算机安全由低到高分为四类七级：D1、C1、C2、B1、B2、B3、A1。其中D1级是不具备最低安全限度的等级，C1和C2级是具备最低安全限度的等级，B1和B2级是具有中等安全保护能力的等级，B3和A1属于最高安全等级</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/14/ncre46/" data-id="cjja5fshl000cbrm18ud6wwon" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ncre45" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/13/ncre45/" class="article-date">
  <time datetime="2018-03-13T03:40:12.000Z" itemprop="datePublished">2018-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/13/ncre45/">计算机四级-网络工程 Day5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li><p>多通道技术增加了系统的并发性 后面还有共享 随机性</p>
</li>
<li><p>用户使用打印输出 系统调用应该是write（）； 是系统提供的调用 printf也会调用write</p>
</li>
<li><p>微内核结构特点 较高的灵活性和可扩充性 提高了系统的可靠性 【更适合分布式系统】</p>
</li>
<li><p>设备忙的 时候不会导致进程终止 比如打印机 Divide 0 的时候会引发异常中断 保留现场 引发中断 </p>
</li>
<li><p>当程序从运行态转换为就绪态的时候，处理机现场信息必须保留在进程控制块中 理解为保留现场</p>
</li>
<li><p>进程控制块对读者不透明 系统对其进行控制 所以用户不可读</p>
</li>
<li><p>申请处理机得不到满足 将进入饥饿状态</p>
</li>
<li><p>管程用来解决同步问题  在条件变量上面进行PV操作 w管程不能同时有两个活跃进程</p>
</li>
<li><p>PV对共享资源读写的代码段称为临界区</p>
</li>
<li><p>在进程同步中 可以对信号量的操作是 初始化信号量 PV操作 不可进行加减</p>
</li>
<li><p>进程在得到处理机运行之前 必须将部分装入内存</p>
</li>
<li><p>优先使用低地址区的算法是首次适应算法 顺序分配算法 </p>
</li>
<li><p>实现页式虚拟存储管理的硬件基础是缺页中断机制</p>
</li>
<li><p>空间局部性是指程序代码的顺序性</p>
</li>
<li><p>建立文件系统的主要目标是实现文件的按名存取</p>
</li>
<li><p>文件的物理结构 ： 顺序结构 索引结构 链接结构</p>
</li>
<li><p>close的操作的目的是将文件控制块写入磁盘或者缓存</p>
</li>
<li><p>设备分配方案是把资源分配给进程</p>
</li>
<li><p>磁盘IO控制主要采用DMA</p>
</li>
<li><p>设备分配的主要数据结构以及分配顺序是 ： 系统设备表 -》 设备控制表 -》 控制器控制表</p>
</li>
<li><p>操作系统类型 ：批处理 交互式 实时 分布式 个人操作系统 网络操作系统 智能卡操作系统</p>
</li>
<li><p>CPU进程优先级和IO没有办法比较</p>
</li>
<li><p>进程调度分为高级调度 中级调度 和低级调度</p>
</li>
<li><p>任何进程必须通过调度才能运行 </p>
</li>
<li><p>交互式系统一般采用时间片轮转的调度方法</p>
</li>
<li><p>信号量初值一定大于等于0</p>
</li>
<li><p>一个进程变化 如果异步 另外的进程不一定变化 同步的话是一定的</p>
</li>
<li><p>进程是资源分配的基本单位 线程是处理机调用的基本单位</p>
</li>
<li><p>页表项中 有效位 修改位 访问位</p>
</li>
<li><p>文件存储空间的管理办法有：空闲块表 空闲块链表 位示图 成组链接法</p>
</li>
<li><p>通道类型 字节多路通道 数据选择通道 数组多路通道</p>
</li>
<li><p>死锁的必要条件 资源互斥使用 部分分配资源 不可剥夺 资源申请成为环路</p>
</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><ul>
<li><p>协议中 语法 控制信息结构和格式 语义控制时间顺序上的推进</p>
</li>
<li><p>万兆网必须的光纤 ae</p>
</li>
<li><p>以太网地址 不兼容IPV6</p>
</li>
<li><p>CSMA/CD 集线器协议 介质访问控制阀 用于多点共享总线 发送数据需要边侦听边发送</p>
</li>
<li><p>802.11采用的是层次结构模型</p>
</li>
<li><p>IP协议三个特点 不可靠 面向无连接 尽最大努力</p>
</li>
<li><p>B向A直接广播 + 255</p>
</li>
<li><p>要求域名服务器系统一次性完成全部名字 - 地址的变换 递归解析</p>
</li>
<li><p>SIP使用URL表示用户 可以基于UDP和TCP</p>
</li>
<li><p>SIMPLE基于SIP XMPP基于URL</p>
</li>
<li><p>社交网络又称社会网络 基于六度分割理论</p>
</li>
<li><p>DES是堆成秘钥 NIST制定 也称DEA Rc5算法属于对称加密算法</p>
</li>
<li><p>OSI模型 不同节点同等层使用协议通信 同一节点相邻层之间通过接口通信</p>
</li>
<li><p>IP路由器功能 转发所受到的IP数据报 为IP数据报选择最佳路径 维护路由表</p>
</li>
<li><p>分片爆头和原来数据报中字段 标识和目的地址相同</p>
</li>
<li><p>混合式P2P网络包含用户节点 搜索节点 索引节点</p>
</li>
<li><p>提高系统解析域名效率 解析从本地域名开始 采用缓存技术</p>
</li>
<li><p>Maze 有种子 有积点 混合P2P结构 URL标识文件位置</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/13/ncre45/" data-id="cjja5fshh000abrm17ip22957" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 戻る</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">次へ &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">アーカイブ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">7月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">5月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">3月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近の投稿</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/07/03/weekend6/">GTX log 6</a>
          </li>
        
          <li>
            <a href="/2018/05/24/gitlab-webhook-jenkins/">Gitlab Jenkins WebHook 持续集成配置踩坑记</a>
          </li>
        
          <li>
            <a href="/2018/05/19/which-str-concat-is-fastest/">PHP-不同Str 拼接方法性能对比</a>
          </li>
        
          <li>
            <a href="/2018/05/06/weekend5/">4.21-5.6周记</a>
          </li>
        
          <li>
            <a href="/2018/04/20/weekend4/">4.7-4.20周记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 GuoQingZhe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>