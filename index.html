<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>GTX Ultimate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Force to fuck off!">
<meta property="og:type" content="website">
<meta property="og:title" content="GTX Ultimate">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="GTX Ultimate">
<meta property="og:description" content="Force to fuck off!">
<meta property="og:locale" content="ja">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GTX Ultimate">
<meta name="twitter:description" content="Force to fuck off!">
  
    <link rel="alternate" href="/atom.xml" title="GTX Ultimate" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GTX Ultimate</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Force Or Blood</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-weekend5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/weekend5/" class="article-date">
  <time datetime="2018-05-06T01:19:33.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/weekend5/">4.21-5.6周记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="trashes"><a href="#trashes" class="headerlink" title="trashes"></a>trashes</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string addslashes ( string $str )</span><br><span class="line"></span><br><span class="line">返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（&apos;）、双引号（&quot;）、反斜线（\）与 NUL（NULL 字符）。</span><br><span class="line"></span><br><span class="line">preg_replace — 执行一个正则表达式的搜索和替换</span><br><span class="line">说明</span><br><span class="line"></span><br><span class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )</span><br><span class="line"></span><br><span class="line">搜索subject中匹配pattern的部分， 以replacement进行替换。</span><br></pre></td></tr></table></figure>
<h2 id="PHP-RdKafka-有延时问题"><a href="#PHP-RdKafka-有延时问题" class="headerlink" title="PHP-RdKafka 有延时问题"></a>PHP-RdKafka 有延时问题</h2><p>作者说是因为没有持久链接，所以会出现推卡夫卡之后会有延迟的现象。量级小还可以 但是量大了之后就很难说。会极大的拖慢php-fpm</p>
<h2 id="Vbird-PHP-var-的变化"><a href="#Vbird-PHP-var-的变化" class="headerlink" title="Vbird-PHP-var 的变化"></a>Vbird-PHP-var 的变化</h2><p>PHP5会出现的写时复制 在PHP7中有所改善，改善的目的就是为了节约内存</p>
<p>PHP改进的宗旨就是 更好的缓存友好度 更低的内存使用 更少的操作数 </p>
<p>当在php5中  这样写是很大性能缺憾的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$arr = range(1, 10000);</span><br><span class="line"></span><br><span class="line">$ref_arr = &amp;$arr; // arr被当做了引用 php5的耿直cow导致性能--</span><br><span class="line"></span><br><span class="line">foreach($arr as &amp;item) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 以上代码在PHP7的性能是PHP5的10000倍左右</span><br></pre></td></tr></table></figure>
<p>为什么会出现这种情况呢？</p>
<p>因为首先PHP7对COW做了优化，不再真正的在引用的时候copy内存</p>
<p>且PHP7对变量的结构体做了优化，结构体由三个Union组成，占24字节</p>
<p>而PHP5的结构体实际占32字节，稍微操作之后大概占48字节，很消耗内存。</p>
<h2 id="Go-sync-Map"><a href="#Go-sync-Map" class="headerlink" title="Go-sync.Map"></a>Go-sync.Map</h2><p>只有Go1.9以上才有的特性</p>
<p>Go的Map并不是线程安全的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main() &#123;</span><br><span class="line">    m := make(map[int]int)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            _ = m[1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        for &#123;</span><br><span class="line">            m[2] = 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    select &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Go1.9之前，有这样的解决方案 直接对map增加一个sync.Mutex锁进行修补 使其达到线程安全</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var counter = struct&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m map[string]int</span><br><span class="line">&#125;&#123;m: make(map[string]int)&#125;</span><br></pre></td></tr></table></figure>
<p>它使用嵌入struct为map增加一个读写锁。</p>
<p>读取数据的时候能够很方便的加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[&quot;some_key&quot;]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(&quot;some_key:&quot;, n)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unter.Lock()</span><br><span class="line">counter.m[&quot;some_key&quot;]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure>
<p>可以说，上面的解决方案相当简洁，并且利用读写锁而不是Mutex可以进一步减少读写的时候因为锁带来的性能。</p>
<p>但是，它在一些场景下也有问题，如果熟悉Java的同学，可以对比一下java的ConcurrentHashMap的实现，在map的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁，Java的解决方案是shard, 内部使用多个锁，每个区间共享一把锁，这样减少了数据共享一把锁带来的性能影响，orcaman提供了这个思路的一个实现： concurrent-map，他也询问了Go相关的开发人员是否在Go中也实现这种方案，由于实现的复杂性，答案是Yes, we considered it.,但是除非有特别的性能提升和应用场景，否则没有进一步的开发消息。</p>
<p>sync.Map的性能优化点？</p>
<p>空间换时间。 通过冗余的两个数据结构（read、dirty）,实现加锁对性能的影响。</p>
<p>使用只读数据（read），避免读写冲突。</p>
<p>动态调整，miss次数多了之后，将dirty数据提升为read。</p>
<p>double-checking。</p>
<p>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</p>
<p>优先从read读取、更新、删除，因为对read的读取不需要锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Map struct &#123;</span><br><span class="line">    // 当涉及到dirty数据的操作的时候，需要使用这个锁</span><br><span class="line">    mu Mutex</span><br><span class="line">    // 一个只读的数据结构，因为只读，所以不会有读写冲突。</span><br><span class="line">    // 所以从这个数据中读取总是安全的。</span><br><span class="line">    // 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。</span><br><span class="line">    read atomic.Value // readOnly</span><br><span class="line">    // dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span><br><span class="line">    // 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span><br><span class="line">    // 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span><br><span class="line">    dirty map[interface&#123;&#125;]*entry</span><br><span class="line">    // 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span><br><span class="line">    // 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span><br><span class="line">    misses int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://studygolang.com/articles/10511" target="_blank" rel="noopener">扩展阅读</a></p>
<h2 id="ISSUE-SVN锁了导致Jenkins无法集成"><a href="#ISSUE-SVN锁了导致Jenkins无法集成" class="headerlink" title="ISSUE-SVN锁了导致Jenkins无法集成"></a>ISSUE-SVN锁了导致Jenkins无法集成</h2><p>SVN的清理命令，我们经常会使用。这个命令的原理，我们还是有必要深究一下的。</p>
<pre><code>当SVN改变你的工作拷贝(或是.svn中的任何信息)，它会尽可能的小心。在进行任何修改操作时，SVN都会把日志记录到日志文件中，然后执行log文件中的命令，
</code></pre><p>并且执行过程中在工作拷贝的相关部分保存一个锁，防止SVN客户端在变更过程中访问工作拷贝。如果SVN的操作中断了（举个例子：进程被杀死了，机器死掉了），</p>
<p>日志文件会保存在硬盘上。通过执行日志文件，SVN可以完成上一次没有完成的操作，你的工作拷贝可以回到一致的状态。</p>
<pre><code>这就是svn clean up命令的功能：它查找工作拷贝中的所有遗留的日志文件，删除进程中工作拷贝的锁。如果SVN告诉你工作拷贝中的一部分已经“锁定”了，
</code></pre><p>你就需要运行这个命令了。</p>
<h2 id="ISSUE-Black-Mac-git-svn报错解决方案"><a href="#ISSUE-Black-Mac-git-svn报错解决方案" class="headerlink" title="ISSUE-Black Mac git-svn报错解决方案"></a>ISSUE-Black Mac git-svn报错解决方案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Can&apos;t locate SVN/Core.pm in @INC (you may need to install the SVN::Core module) (@INC contains: </span><br><span class="line"></span><br><span class="line">/usr/local/git/lib/perl5/site_perl /Applications/SourceTree.app/Contents/Resources/git_local/lib/perl5/site_perl /Library/Perl/5.18/darwin-thread-multi-2level /Library/Perl/5.18 /Network/Library/Perl/5.18/darwin-thread-multi-2level /Network/Library/Perl/5.18 /Library/Perl/Updates/5.18.2 /System/Library/Perl/5.18/darwin-thread-multi-2level /System/Library/Perl/5.18 /System/Library/Perl/Extras/5.18/darwin-thread-multi-2level /System/Library/Perl/Extras/5.18 .) at /Applications/SourceTree.app/Contents/Resources/git_local/lib/perl5/site_perl/Git/SVN/Editor.pm line 5.</span><br><span class="line"></span><br><span class="line">BEGIN failed--compilation aborted at /Applications/SourceTree.app/Contents/Resources/git_local/lib/perl5/site_perl/Git/SVN/Editor.pm line 5.</span><br><span class="line"></span><br><span class="line">Compilation failed in require at /Applications/SourceTree.app/Contents/Resources/git_local/libexec/git-core/git-svn line 81.</span><br><span class="line"></span><br><span class="line">BEGIN failed--compilation aborted at /Applications/SourceTree.app/Contents/Resources/git_local/libexec/git-core/git-svn line 81.</span><br><span class="line"></span><br><span class="line">Completed with errors, see above</span><br></pre></td></tr></table></figure>
<p>首先百度解决办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi-2level/SVN/ /Library/Perl/5.18/SVN</span><br><span class="line"></span><br><span class="line">sudo mkdir /Library/Perl/5.18/auto</span><br><span class="line"></span><br><span class="line">sudo ln -s /Applications/Xcode.app/Contents/Developer/Library/Perl/5.18/darwin-thread-multi-2level/auto/SVN/ /Library/Perl/5.18/auto/SVN</span><br></pre></td></tr></table></figure></p>
<p>但是没有XCODE 只在黑苹果的时候装了Xcode command line</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-select —print-path</span><br></pre></td></tr></table></figure>
<p>拿到相应的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Library/Developer/CommandLineTools/Library/Perl/5.18/darwin-thread-multi-2level</span><br></pre></td></tr></table></figure>
<p>用这个地址替换上面xcode就行</p>
<h1 id="Go-一次性安装所有dependen"><a href="#Go-一次性安装所有dependen" class="headerlink" title="Go 一次性安装所有dependen"></a>Go 一次性安装所有dependen</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get ./...</span><br></pre></td></tr></table></figure>
<h1 id="Go运行时堆栈分析-dev-shm"><a href="#Go运行时堆栈分析-dev-shm" class="headerlink" title="Go运行时堆栈分析 + dev-shm"></a>Go运行时堆栈分析 + dev-shm</h1><p>Go的内存分配器主要也是解决小对象的分配管理和多线程的内存分配问题。内存分配器以32k作为对象大小的定夺标准，小于等于32k的内存对象一律视为小对象，而大于32k的对象就是大对象了。</p>
<p>Cache、Central、Heap是三个核心组件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/weekend5/" data-id="cjgu5ga1p000k2nfymxiqr81h" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-weekend4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/weekend4/" class="article-date">
  <time datetime="2018-04-20T10:43:44.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/weekend4/">4.7-4.20周记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Composer-autoload-static-php报错（PHP54）原因"><a href="#Composer-autoload-static-php报错（PHP54）原因" class="headerlink" title="Composer autoload_static.php报错（PHP54）原因"></a>Composer autoload_static.php报错（PHP54）原因</h1><p>初步定为php版本问题 下次运行composer update/install 的时候使用php5进行运行 防止生成优化class loader代码</p>
<p>可以改为composer 1.10版本以下进行使用</p>
<h1 id="svn包含不到子文件夹问题"><a href="#svn包含不到子文件夹问题" class="headerlink" title="svn包含不到子文件夹问题"></a>svn包含不到子文件夹问题</h1><p>子文件夹中包含.svn文件夹，删除之可以提交</p>
<h1 id="kill-amp-kill-9"><a href="#kill-amp-kill-9" class="headerlink" title="kill &amp; kill -9"></a>kill &amp; kill -9</h1><p>kill和kill -9，两个命令在linux中都有杀死进程的效果，然而两命令的执行过程却大有不同，在程序中如果用错了，可能会造成莫名其妙的现象。<br>执行kill命令，系统会发送一个SIGTERM信号给对应的程序。当程序接收到该signal信号后，将会发生以下事情：</p>
<p>程序立刻停止<br>当程序释放相应资源后再停止<br>程序可能仍然继续运行</p>
<p>大部分程序接收到SIGTERM信号后，会先释放自己的资源，然后再停止。但是也有程序可能接收信号后，做一些其他的事情（如果程序正在等待IO，可能就不会立马做出响应，我在使用wkhtmltopdf转pdf的项目中遇到这现象），也就是说，SIGTERM多半是会被阻塞的。</p>
<p>然而kill -9命令，系统给对应程序发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。</p>
<h1 id="php反引号"><a href="#php反引号" class="headerlink" title="php反引号"></a>php反引号</h1><p>直接执行bash指令</p>
<h1 id="supervisor-Deamons管理工具"><a href="#supervisor-Deamons管理工具" class="headerlink" title="supervisor Deamons管理工具"></a>supervisor Deamons管理工具</h1><p>XXX.conf example<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[program:docpub]</span><br><span class="line">command=php /data1/ms/app_docpub/bin/DocPub.php              ; the program (relative uses PATH, can take args)</span><br><span class="line"></span><br><span class="line">process_name=DOCPUB_%(process_num)s ; process_name expr (default %(program_name)s)</span><br><span class="line"></span><br><span class="line">numprocs=10                    ; number of processes copies to start (def 1)</span><br><span class="line"></span><br><span class="line">autostart=true                ; start at supervisord start (default: true)</span><br><span class="line"></span><br><span class="line">autorestart=true ; whether/when to restart (default: unexpected)</span><br><span class="line"></span><br><span class="line">user=www ; setuid to this UNIX account to run the program</span><br><span class="line"></span><br><span class="line">stdout_logfile=/data1/ms/log/docpub/DOCPUB_%(process_num)s.log        ; stdout log path, NONE for none; default AUTO</span><br><span class="line"></span><br><span class="line">stdout_logfile_maxbytes=50MB   ; max # logfile bytes b4 rotation (default 50MB)</span><br><span class="line"></span><br><span class="line">stdout_logfile_backups=10     ; # of stdout logfile backups (default 10)</span><br><span class="line"></span><br><span class="line">stderr_logfile=/data1/ms/log/docpub/DOCPUB.error.log        ; stderr log path, NONE for none; default AUTO</span><br></pre></td></tr></table></figure></p>
<h1 id="CI-持续集成-—-jenkins"><a href="#CI-持续集成-—-jenkins" class="headerlink" title="CI 持续集成 — jenkins"></a>CI 持续集成 — jenkins</h1><p>CI平台 可以持续的从仓库中拉代码 然后准备执行</p>
<p>Continuous integration，简称CI</p>
<p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p>
<p>它的好处主要有两个。<br>（1）快速发现错误。每完成一点更新，就集成到主干，可以快速发现错误，定位错误也比较容易。<br>（2）防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</p>
<p>持续交付（Continuous delivery）指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。</p>
<p>持续部署（continuous deployment）是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p>
<p>持续部署的前提是能自动化完成测试、构建、部署等步骤。它与持续交付的区别，可以参考下图。</p>
<p>流程<br>根据持续集成的设计，代码从提交到生产，整个过程有以下几步。</p>
<p>4.1 提交<br>流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交（commit）。</p>
<p>4.2 测试（第一轮）<br>代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。</p>
<p>测试有好几种。</p>
<p>单元测试：针对函数或模块的测试</p>
<p>集成测试：针对整体产品的某个功能的测试，又称功能测试</p>
<p>端对端测试：从用户界面直达数据库的全链路测试</p>
<p>第一轮至少要跑单元测试。<br>4.3 构建<br>通过第一轮测试，代码就可以合并进主干，就算可以交付了。</p>
<p>交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。</p>
<p>常用的构建工具如下。</p>
<p>Jenkins</p>
<p>Travis</p>
<p>Codeship</p>
<p>Strider<br>Jenkins和Strider是开源软件，Travis和Codeship对于开源项目可以免费使用。它们都会将构建和测试，在一次运行中执行完成。</p>
<p>4.4 测试（第二轮）</p>
<p>构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时构建步骤也要移到第一轮测试前面。</p>
<p>第二轮是全面测试，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。</p>
<p>需要强调的是，新版本的每一个更新点都必须测试到。如果测试的覆盖率不高，进入后面的部署阶段后，很可能会出现严重的问题。</p>
<p>4.5 部署</p>
<p>通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。</p>
<p>生产服务器将打包文件，解包成本地的一个目录，再将运行路径的符号链接（symlink）指向这个目录，然后重新启动应用。这方面的部署工具有Ansible，Chef，Puppet等。</p>
<p>4.6 回滚<br>一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。</p>
<p>Jenkins 检查日程</p>
<figure class="highlight plain"><figcaption><span>* * * *```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Yii请求流程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 用户发出了访问 URL http://www.example.com/index.php?r=post/show&amp;id=1 的请求， Web 服务器通过执行入口脚本 index.php 处理此请求。</span><br><span class="line">2. 入口脚本创建了一个 应用 实例并执行。</span><br><span class="line">3. 应用从一个叫做 request 的 应用组件 中获得了用户请求的详细信息。</span><br><span class="line">4. 应用在一个名叫 urlManager 的应用组件的帮助下，决定请求的 控制器 和 动作 。在这个例子中，控制器是 post，它代表PostController 类； 动作是 show ，其实际含义由控制器决定。</span><br><span class="line">5. 应用创建了一个所请求控制器的实例以进一步处理用户请求。控制器决定了动作 show 指向控制器类中的一个名为 actionShow 的方法。然后它创建并持行了与动作关联的过滤器（例如访问控制，基准测试）。 如果过滤器允许，动作将被执行。</span><br><span class="line">6. 动作从数据库中读取一个 ID 为 1 的 Post 模型。</span><br><span class="line">7. 动作通过 Post 模型渲染一个名为 show 的 视图。</span><br><span class="line">8. 视图读取并显示 Post 模型的属性。</span><br><span class="line">9. 视图执行一些 小物件。</span><br><span class="line">10. 视图的渲染结果被插入一个 布局。</span><br><span class="line">11. 动作完成视图渲染并将其呈现给用户。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如何确认自己是root</span><br><span class="line"></span><br><span class="line">sudo -s -&gt; no reply -&gt; root</span><br><span class="line"></span><br><span class="line"># saltStack</span><br><span class="line"></span><br><span class="line">远程运维工具</span><br><span class="line"></span><br><span class="line">salt ‘ip’ module.function ‘params &amp; commands’</span><br><span class="line"></span><br><span class="line"># lsyncd</span><br><span class="line"></span><br><span class="line">TDB</span><br><span class="line"></span><br><span class="line"># 事件驱动模型、单进程、多进程比较</span><br><span class="line"></span><br><span class="line">![Alt text](http://ong7eqtw5.bkt.clouddn.com/Pasted%20Graphic%202.tiff &quot;进程模型比较&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。</span><br><span class="line"></span><br><span class="line">在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。</span><br><span class="line"></span><br><span class="line">在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># HAProxy</span><br><span class="line"></span><br><span class="line"># curl 常用命令</span><br></pre></td></tr></table></figure>
<p>curl -o page.html <a href="http://www.linuxidc.com" target="_blank" rel="noopener">http://www.linuxidc.com</a> -o 将page存储下来</p>
<p>curl -x 123.45.67.89:1080 -o page.html <a href="http://www.linuxidc.com" target="_blank" rel="noopener">http://www.linuxidc.com</a> -x 制定proxy和port</p>
<p>curl -x 123.45.67.89:1080 -o page.html -D cookie0001.txt <a href="http://www.linuxidc.com" target="_blank" rel="noopener">http://www.linuxidc.com</a>  -D 存储COOKIE信息</p>
<p>curl -x 123.45.67.89:1080 -o page1.html -D cookie0002.txt -b cookie0001.txt <a href="http://www.linuxidc.com" target="_blank" rel="noopener">http://www.linuxidc.com</a> -b 将文件cookie取出并且使用</p>
<p>-A 确定浏览器信息</p>
<p>-e 设定Referer 就是从哪里来的链接</p>
<p>curl一样可以下载文件</p>
<p>curl -o php.php www.php.php/php.php</p>
<p>-O 直接按照线上的文件名进行下载</p>
<p>curl -O </p>
<p>批量下载</p>
<p>curl -O <a href="http://cgi2.tky.3web.ne.jp/~{zzh,nick}/[001-201].JPG" target="_blank" rel="noopener">http://cgi2.tky.3web.ne.jp/~{zzh,nick}/[001-201].JPG</a></p>
<p>curl -u FTP协议下载</p>
<p>curl -u name:passed ftp://</p>
<p>curl -d 以POST形式传输数据</p>
<p>-H 一个个的http头</p>
<p>```</p>
<h1 id="KMP-敏感词"><a href="#KMP-敏感词" class="headerlink" title="KMP 敏感词"></a>KMP 敏感词</h1><p>TBD</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/weekend4/" data-id="cjgu5ga1t000o2nfyj5e4y3ua" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-weekend3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/weekend3/" class="article-date">
  <time datetime="2018-04-06T13:55:53.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/weekend3/">Weekend Log 4.6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PHP相关"><a href="#PHP相关" class="headerlink" title="PHP相关"></a>PHP相关</h1><h3 id="常用PHP编译-configure"><a href="#常用PHP编译-configure" class="headerlink" title="常用PHP编译 .\/configure"></a>常用PHP编译 .\/configure</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/bin/mysql_config --with-iconv-dir=/usr/local --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-discard-path   --enable-mbregex --enable-fastcgi --enable-fpm --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-openssl --with-mhash  --enable-sockets --with-xmlrpc --enable-zip --enable-pdo --with-pdo-mysql --with-mysql</span><br><span class="line">// 需要安装MySQL 以及一些其他的常用lib</span><br></pre></td></tr></table></figure>
<h3 id="PHP-JSON处理"><a href="#PHP-JSON处理" class="headerlink" title="PHP JSON处理"></a>PHP JSON处理</h3><p>对于返回的util 可以使用5.4开始使用的trait进行嵌入 然后self\:\:调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">return json_encode($body, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);</span><br><span class="line"></span><br><span class="line">JSON_UNESCAPED_SLASHES (integer)</span><br><span class="line">不要编码 /。 自 PHP 5.4.0 起生效。</span><br><span class="line">JSON_UNESCAPED_UNICODE (integer)</span><br><span class="line">以字面编码多字节 Unicode 字符（默认是编码成 \uXXXX）。 自 PHP 5.4.0 起生效</span><br><span class="line"></span><br><span class="line">string json_last_error_msg ( void ) // php55以上才有这个方法 得到json转换的错误</span><br></pre></td></tr></table></figure></p>
<h3 id="PHP-FPM搭建中NGINX出现file-not-found的问题-参见备忘录"><a href="#PHP-FPM搭建中NGINX出现file-not-found的问题-参见备忘录" class="headerlink" title="PHP-FPM搭建中NGINX出现file not found的问题-参见备忘录"></a>PHP-FPM搭建中NGINX出现file not found的问题-参见备忘录</h3><h1 id="TODOLIST"><a href="#TODOLIST" class="headerlink" title="TODOLIST"></a>TODOLIST</h1><h3 id="centos上配一个LNMP"><a href="#centos上配一个LNMP" class="headerlink" title="centos上配一个LNMP"></a>centos上配一个LNMP</h3><h3 id="Linux-MOUNT-AWK等命令"><a href="#Linux-MOUNT-AWK等命令" class="headerlink" title="Linux MOUNT AWK等命令"></a>Linux MOUNT AWK等命令</h3><h3 id="Kafka、RabbitMQ、Hadoop、Spark、Redis、Memcached等工具类的使用"><a href="#Kafka、RabbitMQ、Hadoop、Spark、Redis、Memcached等工具类的使用" class="headerlink" title="Kafka、RabbitMQ、Hadoop、Spark、Redis、Memcached等工具类的使用"></a>Kafka、RabbitMQ、Hadoop、Spark、Redis、Memcached等工具类的使用</h3><h3 id="PHP-YII框架实现"><a href="#PHP-YII框架实现" class="headerlink" title="PHP YII框架实现"></a>PHP YII框架实现</h3><p>目前就这些，争取很快赶上公司的进度，能够出一些代码贡献！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/06/weekend3/" data-id="cjgu5ga1r000m2nfyn5oi97zc" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-weekend2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/30/weekend2/" class="article-date">
  <time datetime="2018-03-30T06:51:27.000Z" itemprop="datePublished">2018-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/30/weekend2/">3.30一周拾遗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本周主要围绕PHP的内部实现做了探索，同时进行诸多面试。并且收到了新浪实习offer以及金山西山居的邀请。当然是前者优先了。</p>
<h1 id="一些杂项的积累"><a href="#一些杂项的积累" class="headerlink" title="一些杂项的积累"></a>一些杂项的积累</h1><h3 id="PHP配置文件找不到怎么破"><a href="#PHP配置文件找不到怎么破" class="headerlink" title="PHP配置文件找不到怎么破"></a>PHP配置文件找不到怎么破</h3><p>使用PHP的phpinfo();来进行查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// PHP CLI</span><br><span class="line"></span><br><span class="line">php -r &quot;phpinfo()&quot; | grep &quot;Loaded Configuration File&quot; &amp;&amp; &quot;Configuration FIle&quot;；</span><br><span class="line">// 但是找不到Loaded怎么办 或者Loaded出来是 none</span><br><span class="line">// 一般是新的PHP没有将PHP.ini放到指定位置 </span><br><span class="line">// 原始的PHPINI可以从源码包找到 php.ini.production cp过去就可以了</span><br></pre></td></tr></table></figure>
<h3 id="Segment-Fault-段错误-怎么进行debug"><a href="#Segment-Fault-段错误-怎么进行debug" class="headerlink" title="Segment Fault 段错误 怎么进行debug"></a>Segment Fault 段错误 怎么进行debug</h3><p>首先Linux系统默认是不dump Core的 需要设置unlimit 让系统对Fault的Core进行Dump</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br></pre></td></tr></table></figure>
<p>就可以将出错时的内核文件进行输出 .Core.XXXX文件</p>
<p>然后 yum install gdb 然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb php core.XXXX 进行分析 可以找出出错的行数</span><br></pre></td></tr></table></figure>
<h3 id="未解决问题-对PHP扩展开发的时候-return-value-used变量不能用"><a href="#未解决问题-对PHP扩展开发的时候-return-value-used变量不能用" class="headerlink" title="[未解决问题] 对PHP扩展开发的时候 return_value_used变量不能用"></a>[未解决问题] 对PHP扩展开发的时候 return_value_used变量不能用</h3><p>提示未定义 而且在源码包内对PHP_FUNCTION的宏定义中找不到这个变量 难道是PHP7更新之后自动可以GC的缘故？</p>
<h1 id="Redis-内存数据库数据结构整理"><a href="#Redis-内存数据库数据结构整理" class="headerlink" title="Redis 内存数据库数据结构整理"></a>Redis 内存数据库数据结构整理</h1><h3 id="SDS-（动态字符串）"><a href="#SDS-（动态字符串）" class="headerlink" title="SDS （动态字符串）"></a>SDS （动态字符串）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">	int len; // SDS遵循C字符串以 &apos;\0&apos;为结尾的规则 但是 末尾的空不计算在len内</span><br><span class="line">	// 这样获取的长度的速度就是O(1)</span><br><span class="line">	// 还可以杜绝缓冲区溢出 在操作之前可以先看一下是否有足够的空间 如果没有就malloc C语言本身不记录string的长度</span><br><span class="line">	// 减少修改字符串带来的内存重新分配次数</span><br><span class="line">	int free;</span><br><span class="line">	char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDS使用空间预分配和惰性空间释放策略 提升性能</p>
<h4 id="空间与分配："><a href="#空间与分配：" class="headerlink" title="空间与分配："></a>空间与分配：</h4><p>如果小于1MB</p>
<p>预分配相同的size</p>
<p>如果大于1MB </p>
<p>预分配1MB的size</p>
<h4 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h4><p>避免使用 \0 导致字符串截断</p>
<p>Redis在读取字符串的时候是依据 SDS结构之内的len进行读取 有多少读多少</p>
<h4 id="对比C字符串的优点"><a href="#对比C字符串的优点" class="headerlink" title="对比C字符串的优点"></a>对比C字符串的优点</h4><ul>
<li><p>O(1)获取长度复杂度</p>
</li>
<li><p>杜绝缓冲区溢出</p>
</li>
<li><p>减少修改字符串带来的内存重新分配次数</p>
</li>
<li><p>二进制安全</p>
</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表提供高效的结点重排能力</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">	struct listNode *prev;</span><br><span class="line">	struct listNode *next;</span><br><span class="line">	void *value;</span><br><span class="line">&#125;listNode;</span><br><span class="line"></span><br><span class="line">typedef struct list &#123;</span><br><span class="line">	listNode *head;</span><br><span class="line">	listNode *tail;</span><br><span class="line">	unsigned long len;</span><br><span class="line">	void *(*dup)(void *ptr)</span><br><span class="line">	void *(*free)(void *ptr)</span><br><span class="line">	int (*match)(void *ptr)</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure>
<h4 id="API时间复杂度"><a href="#API时间复杂度" class="headerlink" title="API时间复杂度"></a>API时间复杂度</h4><ul>
<li><p>返回值所在的index O(N)</p>
</li>
<li><p>返回index所在的值 O(N)</p>
</li>
<li><p>删除指定结点O(N)</p>
</li>
<li><p>复制一个副本O(N)</p>
</li>
<li><p>释放链表 O(N)</p>
</li>
</ul>
<h3 id="字典—使用哈希表实现"><a href="#字典—使用哈希表实现" class="headerlink" title="字典—使用哈希表实现"></a>字典—使用哈希表实现</h3><p>又被称为符号表、关联数组、或者映射</p>
<p>字典使用哈希表实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123; // 哈希表结点</span><br><span class="line">	void *key;</span><br><span class="line">	</span><br><span class="line">	union &#123;</span><br><span class="line">	 // 同样采用联合体来节约内存</span><br><span class="line">		void *val;</span><br><span class="line">		uint64 _tu64;</span><br><span class="line">		int64 _ts64;</span><br><span class="line">	&#125;v;</span><br><span class="line">	struct dictEntry *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct dict&#123;</span><br><span class="line">	dictType *type;</span><br><span class="line">	void *privdata;</span><br><span class="line">	</span><br><span class="line">	dictht ht[2];</span><br><span class="line">	</span><br><span class="line">	// 平时数据会存在第一个HashTable 当进行rehash的时候使用第二个HashTable</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决HashTable的方法"><a href="#解决HashTable的方法" class="headerlink" title="解决HashTable的方法"></a>解决HashTable的方法</h4><p>有链接法和开放寻址法</p>
<p>链接法就是当发生index冲突的时候，在index处形成链表，新插入的在前面</p>
<p>开放寻址法就是发生index冲突的时候，自动向下寻址</p>
<h4 id="HashTable的API时间复杂度"><a href="#HashTable的API时间复杂度" class="headerlink" title="HashTable的API时间复杂度"></a>HashTable的API时间复杂度</h4><ul>
<li><p>向HashTable加新的元素 O(1)</p>
</li>
<li><p>释放HashTable O(N)</p>
</li>
</ul>
<h3 id="跳跃表-有序set的实现之一"><a href="#跳跃表-有序set的实现之一" class="headerlink" title="跳跃表-有序set的实现之一"></a>跳跃表-有序set的实现之一</h3><p>跳跃表支持平均O(logN)、最坏O(N)的复杂度查找</p>
<p>。。。说实话跳跃表没咋看懂</p>
<h4 id="跳跃表API时间复杂度"><a href="#跳跃表API时间复杂度" class="headerlink" title="跳跃表API时间复杂度"></a>跳跃表API时间复杂度</h4><ul>
<li><p>寻找 删除 返回排位 平均O(logN) 最坏O(N)</p>
</li>
<li><p>给定一个范围 如果有一个在范围之内 就可以 O(1)</p>
</li>
</ul>
<h3 id="整数集合-set的单纯整数实现"><a href="#整数集合-set的单纯整数实现" class="headerlink" title="整数集合 set的单纯整数实现"></a>整数集合 set的单纯整数实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">	uint32_t encoding;</span><br><span class="line">	</span><br><span class="line">	uint32_t length;</span><br><span class="line">	</span><br><span class="line">	int 8_t content[]; // 不仅会保存int8的数据 保存类型取决于encoding;</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<h4 id="整数集合API时间复杂度"><a href="#整数集合API时间复杂度" class="headerlink" title="整数集合API时间复杂度"></a>整数集合API时间复杂度</h4><ul>
<li><p>添加新元素复杂度为O(N) // 因为每次操作都可能引起升级  所以会大一点</p>
</li>
<li><p>整数集合不会降级 保证性能</p>
</li>
</ul>
<h3 id="压缩列表-列表键和哈希键的实现之一"><a href="#压缩列表-列表键和哈希键的实现之一" class="headerlink" title="压缩列表 列表键和哈希键的实现之一"></a>压缩列表 列表键和哈希键的实现之一</h3><p>压缩列表是连续内存构成的顺序结构</p>
<p>[zlbytes, zltail, zllen, entry1, entry2, …, zlend];</p>
<p>zlbytes: 表示压缩列表总长度</p>
<p>zltail： 压缩列表尾部指针P</p>
<p>zllen: 压缩列表数据个数</p>
<p>通过以上三个参数 可以分别计算出每个数据点的指针 从尾部开始计算即可</p>
<h4 id="压缩列表结点构成"><a href="#压缩列表结点构成" class="headerlink" title="压缩列表结点构成"></a>压缩列表结点构成</h4><p>[previous_entry_length, encoding, content]</p>
<p>pre记录了前一个结点的长度</p>
<p>可以根据当前结点的起始地址计算出前一个结点的起始地址指针</p>
<h4 id="压缩列表API时间复杂度"><a href="#压缩列表API时间复杂度" class="headerlink" title="压缩列表API时间复杂度"></a>压缩列表API时间复杂度</h4><ul>
<li><p>创建一个包含指定结点的压缩列表 O(N) 最坏O(N*N)</p>
</li>
<li><p>插入结点 O(N) 最坏O(N*N)</p>
</li>
<li><p>返回index的结点O(N)</p>
</li>
<li><p>找到包含指定值的 O(N) 最坏O(N*N)</p>
</li>
<li><p>删除指定结点 O(N) 最坏O(N*N)</p>
</li>
<li><p>返回结点数量 结点数量小于65535 O(1) 最坏O(N*N)</p>
</li>
</ul>
<h2 id="REDIS对象以及实现"><a href="#REDIS对象以及实现" class="headerlink" title="REDIS对象以及实现"></a>REDIS对象以及实现</h2><h3 id="Redis-string"><a href="#Redis-string" class="headerlink" title="Redis_string"></a>Redis_string</h3><p>int raw embstr;</p>
<h3 id="redis-list"><a href="#redis-list" class="headerlink" title="redis_list"></a>redis_list</h3><p>ziplist hashtable intlist</p>
<h3 id="redis-hash"><a href="#redis-hash" class="headerlink" title="redis_hash"></a>redis_hash</h3><p>ziplist hashtable</p>
<h3 id="redis-set"><a href="#redis-set" class="headerlink" title="redis_set"></a>redis_set</h3><p>intset hashtable</p>
<h3 id="reids-zset"><a href="#reids-zset" class="headerlink" title="reids_zset"></a>reids_zset</h3><p>ziplist skiplist</p>
<h1 id="PHP扩展开发相关【未完待续】"><a href="#PHP扩展开发相关【未完待续】" class="headerlink" title="PHP扩展开发相关【未完待续】"></a>PHP扩展开发相关【未完待续】</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/30/weekend2/" data-id="cjgu5ga1s000n2nfykf6hvh6v" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-weekend1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/25/weekend1/" class="article-date">
  <time datetime="2018-03-25T01:16:25.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/25/weekend1/">3.25周 一周拾遗</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PHP设计模式"><a href="#PHP设计模式" class="headerlink" title="PHP设计模式"></a>PHP设计模式</h1><h2 id="自动加载"><a href="#自动加载" class="headerlink" title="自动加载"></a>自动加载</h2><h4 id="autoload"><a href="#autoload" class="headerlink" title="__autoload();"></a>__autoload();</h4><p>魔术方法，当加载不存在的类的时候会使用这个方法，每个文件中只能存在一次，而且抛出的Exception是不可catch的。</p>
<h4 id="spl-autoload-register"><a href="#spl-autoload-register" class="headerlink" title="spl_autoload_register();"></a>spl_autoload_register();</h4><p>可以调用用户自己的ClassLoader， Composer就是使用这种方法实现类的自动加载</p>
<p>每个文件中可有多个spl_autoload_register();方法，调用更加灵活;</p>
<p>抛出的Exception可以catch；</p>
<p>而且可以使用 spl_autoload_unregister();进行自动加载关闭，节省内存空间.</p>
<ul>
<li>自动加载不可用于CLI模式</li>
</ul>
<h4 id="PSR-0规范"><a href="#PSR-0规范" class="headerlink" title="PSR-0规范"></a>PSR-0规范</h4><p>PSR-0 (Autoloading Standard) 自动加载标准 </p>
<p>PSR-1 (Basic Coding Standard) 基础编码标准 </p>
<p>PSR-2 (Coding Style Guide) 编码风格向导 </p>
<p>PSR-3 (Logger Interface) 日志接口 </p>
<p>PSR-4 (Improved Autoloading) 自动加载的增强版，可以替换掉PSR-0了。</p>
<p>一个完全合格的namespace和class必须符合这样的结构：“\&lt; Vendor Name&gt;(&lt; Namespace&gt;)*&lt; Class Name&gt;”</p>
<p>每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字）</p>
<p>每个namespace可以有多个子namespace</p>
<p>当从文件系统中加载时，每个namespace的分隔符(/)要转换成 DIRECTORY_SEPARATOR(操作系统路径分隔符)</p>
<p>在类名中，每个下划线(_)符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在namespace中，下划线(_)符号是没有（特殊）意义的。</p>
<p>当从文件系统中载入时，合格的namespace和class一定是以 .php 结尾的</p>
<p>verdor name,namespaces,class名可以由大小写字母组合而成（大小写敏感的）</p>
<h4 id="PSR-4-规范"><a href="#PSR-4-规范" class="headerlink" title="PSR-4 规范"></a>PSR-4 规范</h4><p>废除了支持PHP5.3代码以前的规范，并且去掉的下划线的意义。</p>
<h2 id="八个常用设计模式"><a href="#八个常用设计模式" class="headerlink" title="八个常用设计模式"></a>八个常用设计模式</h2><h3 id="单例模式-Eg。数据库连接"><a href="#单例模式-Eg。数据库连接" class="headerlink" title="单例模式 Eg。数据库连接"></a>单例模式 Eg。数据库连接</h3><p>要求：</p>
<ol>
<li><p>$_instance必须为静态私有变量</p>
</li>
<li><p>构造函数  析构函数 拷贝函数必须为私有 防止外界实例化对象</p>
</li>
<li><p>getInstance()方法必须公有，返回实例一个引用。</p>
</li>
</ol>
<p>节省内存 避免频繁new</p>
<h3 id="工厂模式：生产对象使用"><a href="#工厂模式：生产对象使用" class="headerlink" title="工厂模式：生产对象使用"></a>工厂模式：生产对象使用</h3><p>工厂模式可以避免类改名字之后，其他生成对象的代码都要一一修改，使用工厂可以避免频繁修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Test1.php</span><br><span class="line">&lt;?php</span><br><span class="line">class Test1&#123;</span><br><span class="line">    static function test()&#123;</span><br><span class="line">        echo __FILE__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory.php</span><br><span class="line">&lt;?php</span><br><span class="line">class Factory&#123;</span><br><span class="line">    /*</span><br><span class="line">     * 如果某个类在很多的文件中都new ClassName()，那么万一这个类的名字</span><br><span class="line">     * 发生变更或者参数发生变化，如果不使用工厂模式，就需要修改每一个PHP</span><br><span class="line">     * 代码，使用了工厂模式之后，只需要修改工厂类或者方法就可以了。</span><br><span class="line">     */</span><br><span class="line">    static function createDatabase()&#123;</span><br><span class="line">        $test = new Test1();</span><br><span class="line">        return $test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.php</span><br><span class="line">&lt;?php</span><br><span class="line">spl_autoload_register(&apos;autoload1&apos;);</span><br><span class="line"></span><br><span class="line">$test = Factory::createDatabase();</span><br><span class="line">$test-&gt;test();</span><br><span class="line">function autoload1($class)&#123;</span><br><span class="line">    $dir  = __DIR__;</span><br><span class="line">    $requireFile = $dir.&quot;\\&quot;.$class.&quot;.php&quot;;</span><br><span class="line">    require $requireFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册模式：解决全局局部共享对象使用"><a href="#注册模式：解决全局局部共享对象使用" class="headerlink" title="注册模式：解决全局局部共享对象使用"></a>注册模式：解决全局局部共享对象使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Register</span><br><span class="line">&#123;</span><br><span class="line">    protected static  $objects;</span><br><span class="line">    function set($alias,$object)//将对象注册到全局的树上</span><br><span class="line">    &#123;</span><br><span class="line">        self::$objects[$alias]=$object;//将对象放到树上</span><br><span class="line">    &#125;</span><br><span class="line">    static function get($name)&#123;</span><br><span class="line">        return self::$objects[$name];//获取某个注册到树上的对象</span><br><span class="line">    &#125;</span><br><span class="line">    function _unset($alias)</span><br><span class="line">    &#123;</span><br><span class="line">        unset(self::$objects[$alias]);//移除某个注册到树上的对象。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适配器模式，类似于下面的决策模式"><a href="#适配器模式，类似于下面的决策模式" class="headerlink" title="适配器模式，类似于下面的决策模式"></a>适配器模式，类似于下面的决策模式</h3><p>将各种不同的操作封装成接口API 比如数据库操作有MySQL，MySQLi，PDO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">接口 IDatabase</span><br><span class="line">&lt;?php</span><br><span class="line">namespace IMooc;</span><br><span class="line">interface IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    function connect($host, $user, $passwd, $dbname);</span><br><span class="line">    function query($sql);</span><br><span class="line">    function close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQL</span><br><span class="line">&lt;?php</span><br><span class="line">namespace IMooc\Database;</span><br><span class="line">use IMooc\IDatabase;</span><br><span class="line">class MySQL implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    protected $conn;</span><br><span class="line">    function connect($host, $user, $passwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        $conn = mysql_connect($host, $user, $passwd);</span><br><span class="line">        mysql_select_db($dbname, $conn);</span><br><span class="line">        $this-&gt;conn = $conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        $res = mysql_query($sql, $this-&gt;conn);</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        mysql_close($this-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MySQLi</span><br><span class="line">&lt;?php</span><br><span class="line">namespace IMooc\Database;</span><br><span class="line">use IMooc\IDatabase;</span><br><span class="line">class MySQLi implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    protected $conn;</span><br><span class="line"></span><br><span class="line">    function connect($host, $user, $passwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        $conn = mysqli_connect($host, $user, $passwd, $dbname);</span><br><span class="line">        $this-&gt;conn = $conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        return mysqli_query($this-&gt;conn, $sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        mysqli_close($this-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="策略模式：IOC思想-DI实现"><a href="#策略模式：IOC思想-DI实现" class="headerlink" title="策略模式：IOC思想 DI实现"></a>策略模式：IOC思想 DI实现</h3><p>也就是控制反转 依赖注入</p>
<p>防止种类过多时候发生太多if导致代码维护艰难</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">UserStrategy.php</span><br><span class="line">&lt;?php</span><br><span class="line">/*</span><br><span class="line"> * 声明策略文件的接口，约定策略包含的行为。</span><br><span class="line"> */</span><br><span class="line">interface UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">    function showAd();</span><br><span class="line">    function showCategory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MaleUser.php</span><br><span class="line">&lt;?php</span><br><span class="line">require_once &apos;Loader.php&apos;;</span><br><span class="line">class MaleUser implements UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">    function showAd()&#123;</span><br><span class="line">        echo &quot;IPhone6s&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function showCategory()&#123;</span><br><span class="line">        echo &quot;电子产品&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Page.php//执行文件</span><br><span class="line">&lt;?php</span><br><span class="line">require_once &apos;Loader.php&apos;;</span><br><span class="line">class Page</span><br><span class="line">&#123;</span><br><span class="line">    protected $strategy;</span><br><span class="line">    function index()&#123;</span><br><span class="line">        echo &quot;AD&quot;;</span><br><span class="line">        $this-&gt;strategy-&gt;showAd();</span><br><span class="line">        echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">        echo &quot;Category&quot;;</span><br><span class="line">        $this-&gt;strategy-&gt;showCategory();</span><br><span class="line">        echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function setStrategy(UserStrategy $strategy)&#123;</span><br><span class="line">        $this-&gt;strategy=$strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$page = new Page();</span><br><span class="line">if(isset($_GET[&apos;male&apos;]))&#123;</span><br><span class="line">    $strategy = new MaleUser();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    $strategy = new FemaleUser();</span><br><span class="line">&#125;</span><br><span class="line">$page-&gt;setStrategy($strategy);</span><br><span class="line">$page-&gt;index();</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>适用于一带多频繁更新的操作，比如业务逻辑中一个数据更改导致其他表的数据也要跟着更改，直接硬编码更改的操作的不太好的，而且后期的维护也很不利，使用观察者模式可以进行事件发布，然后进行foreach进行更新操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EventGenerator.php</span><br><span class="line">&lt;?php</span><br><span class="line">require_once &apos;Loader.php&apos;;</span><br><span class="line">abstract class EventGenerator&#123;</span><br><span class="line">    private $observers = array();</span><br><span class="line">    function addObserver(Observer $observer)&#123;</span><br><span class="line">        $this-&gt;observers[]=$observer;</span><br><span class="line">    &#125;</span><br><span class="line">    function notify()&#123;</span><br><span class="line">        foreach ($this-&gt;observers as $observer)&#123;</span><br><span class="line">            $observer-&gt;update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observer.php</span><br><span class="line">&lt;?php</span><br><span class="line">require_once &apos;Loader.php&apos;;</span><br><span class="line">interface Observer&#123;</span><br><span class="line">    function update();//这里就是在事件发生后要执行的逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span><br><span class="line">require &apos;Loader.php&apos;;</span><br><span class="line">class Event extends EventGenerator&#123;</span><br><span class="line">    function triger()&#123;</span><br><span class="line">        echo &quot;Event&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Observer1 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑1&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Observer2 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑2&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$event = new Event();</span><br><span class="line">$event-&gt;addObserver(new Observer1());</span><br><span class="line">$event-&gt;addObserver(new Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>和工厂模式类似，适合创建大对象的时候，可以节约一下内存开销</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Index.php</span><br><span class="line">&lt;?php</span><br><span class="line">require &apos;Loader.php&apos;;</span><br><span class="line">$c = new Canvas();</span><br><span class="line">$c-&gt;init();</span><br><span class="line">/ $canvas1 = new Canvas();</span><br><span class="line">// $canvas1-&gt;init();</span><br><span class="line">$canvas1 = clone $c;//通过克隆，可以省去init()方法，这个方法循环两百次</span><br><span class="line">//去产生一个数组。当项目中需要产生很多的这样的对象时，就会new很多的对象，那样</span><br><span class="line">//是非常消耗性能的。</span><br><span class="line">$canvas1-&gt;rect(2, 2, 8, 8);</span><br><span class="line">$canvas1-&gt;draw();</span><br><span class="line">echo &quot;-----------------------------------------&lt;br&gt;&quot;;</span><br><span class="line">// $canvas2 = new Canvas();</span><br><span class="line">// $canvas2-&gt;init();</span><br><span class="line">$canvas2 = clone $c;</span><br><span class="line">$canvas2-&gt;rect(1, 4, 8, 8);</span><br><span class="line">$canvas2-&gt;draw();</span><br></pre></td></tr></table></figure>
<h1 id="MySQL-性能索引"><a href="#MySQL-性能索引" class="headerlink" title="MySQL 性能索引"></a>MySQL 性能索引</h1><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><ol>
<li>B+ Tree</li>
</ol>
<p>key放在叶子节点内的节点，叶子节点存放value 这样可以保证放更多的key，减少树的高度，树的高度的减少导致磁盘IO减少，可以优化性能。叶子节点处有相互链接的指针。InnoDB采用B+Tree可以将随机IO转换为顺序IO来提升效率。</p>
<ol>
<li>搜索树</li>
</ol>
<p>父节点大于左孩子节点，右孩子节点大于父节点</p>
<ol>
<li>平衡二叉树</li>
</ol>
<p>二叉树，但是要求任意一个节点的左右孩子节点高度差不大于1</p>
<ol>
<li>Hash Struct</li>
</ol>
<p>哈希结构仅能满足 Exist In 等查询，不能使用范围查询。无法进行排序查询。不支持部分索引</p>
<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><h3 id="聚集索引Primary"><a href="#聚集索引Primary" class="headerlink" title="聚集索引Primary"></a>聚集索引Primary</h3><p>InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，这是聚簇索引</p>
<p>非聚簇索引，叶子节点上的data是主键(所以聚簇索引的key，不能过长)。</p>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li><p>变随机IO为顺序IO</p>
</li>
<li><p>避免全表扫描</p>
</li>
<li><p>可以帮助服务器避免排序或者临时表</p>
</li>
</ul>
<p>索引对中小型表会比较高效，大型表需要考虑一下分区。</p>
<h2 id="索引的创建方法"><a href="#索引的创建方法" class="headerlink" title="索引的创建方法"></a>索引的创建方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create index `idx_img` on newuser(`img`);</span><br><span class="line"></span><br><span class="line">alter table newuser add index `idx_extra_img` (`isDeleted`, `img`)</span><br><span class="line"></span><br><span class="line">drop index `idx_img` on newuser;</span><br><span class="line"></span><br><span class="line">// 强制走索引的方式</span><br><span class="line">select * from newuser force index where xxxx;</span><br></pre></td></tr></table></figure>
<h2 id="索引的注意"><a href="#索引的注意" class="headerlink" title="索引的注意"></a>索引的注意</h2><ul>
<li><p>不鼓励使用like 不可以全部模糊查询  可以 55kai% 这样查</p>
</li>
<li><p>不可以进行列上操作 比如count sum等都会全表扫描 性能很差</p>
</li>
<li><p>不适用Not in  &lt;&gt; 操作。</p>
</li>
<li><p>尽可能使用分解关联查询 这样分解后 sql简单，利于MySQL缓存、减少锁竞争 更好的扩展和维护性。</p>
</li>
</ul>
<h1 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h1><h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><p>三部分：</p>
<p>请求起始行、消息头、消息体</p>
<h2 id="分块传送"><a href="#分块传送" class="headerlink" title="分块传送"></a>分块传送</h2><p>当浏览器想服务器请求一个资源，这个资源是一个动态资源，服务器无法预知资源的大小，就应该采用分块传送</p>
<p>服务器先生成一个thunk 发送这个chunk 再生成 在发送 直到发送完成。</p>
<p>分块发送需要在请求头增加一个transfer-encoding:thunked</p>
<h2 id="持久链接"><a href="#持久链接" class="headerlink" title="持久链接"></a>持久链接</h2><p>HTTP早期版本因为链接不可复用，性能很差，TCP1.5的RTT（三次握手）和慢启动会拖慢速度。</p>
<p>1.1版本引入keep-alive的connection头，如果服务器和客户端都确定keep-alive的话，在一个TCP上面可以传送多个请求。</p>
<p>持久链接也不应该一直保持，每个人都会占用服务器资源，如果PV太高，服务器资源也会jinzhang</p>
<p>应该配置KeepAliveTimeout和KeepAliveRequests两个参数 限时限量</p>
<h2 id="PipeLine管线化"><a href="#PipeLine管线化" class="headerlink" title="PipeLine管线化"></a>PipeLine管线化</h2><p>也就是一个TCP上面可以产送多个HTTP请求，但是请求的顺序必须和返回的顺序一致</p>
<h2 id="无状态性"><a href="#无状态性" class="headerlink" title="无状态性"></a>无状态性</h2><p>指的是协议层无状态性 两次请求并没有任何关系。通过会话控制可以保证访问的状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/25/weekend1/" data-id="cjgu5ga1q000l2nfyf236h1n1" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql-acid" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/mysql-acid/" class="article-date">
  <time datetime="2018-03-20T12:53:40.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/mysql-acid/">MySQL 事务处理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#MySQL 事务</p>
<h3 id="事务是为了控制并发并且保护数据完整性的一种解决办法"><a href="#事务是为了控制并发并且保护数据完整性的一种解决办法" class="headerlink" title="事务是为了控制并发并且保护数据完整性的一种解决办法"></a>事务是为了控制并发并且保护数据完整性的一种解决办法</h3><h2 id="事务四要素-ACID"><a href="#事务四要素-ACID" class="headerlink" title="事务四要素 ACID"></a>事务四要素 ACID</h2><p>1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p>
<p>2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p>
<p>3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
<p>4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p>
<h2 id="事务的问题"><a href="#事务的问题" class="headerlink" title="事务的问题"></a>事务的问题</h2><p>1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p>
<p>2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p>
<p>3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
<h2 id="数据的范式"><a href="#数据的范式" class="headerlink" title="数据的范式"></a>数据的范式</h2><p>1NF 原子性 字段不可再分</p>
<p>2NF 唯一性 字段唯一</p>
<p>3NF 冗余性 字段不可由其他字段派生</p>
<h2 id="MYSQL事务隔离级别"><a href="#MYSQL事务隔离级别" class="headerlink" title="MYSQL事务隔离级别"></a>MYSQL事务隔离级别</h2><table><br>  <tr><br>    <th>事务隔离级别</th><br>    <th>脏读</th><br>    <th>不可重复读</th><br>    <th>幻读</th><br>  </tr><br>  <tr><br>    <td bgcolor="#eeeeee">读未提交（read-uncommitted）</td><br>    <td> 是  </td><br>    <td> 是  </td><br>    <td> 是  </td><br>  </tr><br>  <tr><br>    <td bgcolor="#eeeeee">读提交（read-committed）</td><br>    <td> 否  </td><br>    <td> 是  </td><br>    <td> 是  </td><br>  </tr><tr><br>    <td bgcolor="#eeeeee">可重复读（repeatable-read）</td><br>    <td> 否  </td><br>    <td> 否  </td><br>    <td> 是  </td><br>  </tr><br>  <tr><br>    <td bgcolor="#eeeeee">串行化（serializable）</td><br>    <td> 否  </td><br>    <td> 否  </td><br>    <td> 否  </td><br>  </tr><br></table>

<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>1、SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p>
<p>2、mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行</p>
<p>3、事务隔离级别为读提交时，写数据只会锁住相应的行</p>
<p>4、事务隔离级别为可重复读时，写数据会锁住整张表</p>
<p>5、事务隔离级别为串行化时，读写数据都会锁住整张表</p>
<p>6、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/mysql-acid/" data-id="cjgu5ga1d00082nfyemwbl3sm" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-autoloader" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/autoloader/" class="article-date">
  <time datetime="2018-03-20T10:47:45.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/autoloader/">自动加载以及Composer的实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="类的自动加载"><a href="#类的自动加载" class="headerlink" title="类的自动加载"></a>类的自动加载</h1><p>两个函数 __autoload()魔术方法、spl_autoload_register</p>
<p>当php文件中使用了new关键字实例化一个对象时，如果该类没有在本php文件中被定义，将会触发__autoload函数</p>
<h3 id="autoload"><a href="#autoload" class="headerlink" title="__autoload"></a>__autoload</h3><ol>
<li><p>运行到new Animal()时，发现 class Animal没有定义</p>
</li>
<li><p>触发了__autoload函数，该函数引进了Animal.php文件</p>
</li>
<li><p>实例化成功。</p>
</li>
</ol>
<h3 id="spl-autoload-register"><a href="#spl-autoload-register" class="headerlink" title="spl_autoload_register"></a>spl_autoload_register</h3><p>（注意：当文件中同时出现__autoload和spl_autoload_register时，以spl_autoload_register为准）</p>
<p>bool spl_autoload_register ([ callable autoloadfunction[,boolthrow = true [, bool $prepend = false ]]] )</p>
<p>autoload_function</p>
<ul>
<li>欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。</li>
</ul>
<p>throw</p>
<ul>
<li>此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。</li>
</ul>
<p>prepend</p>
<ul>
<li>如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#main.php</span><br><span class="line">&lt;?php</span><br><span class="line">  function myLoad($classname)&#123;</span><br><span class="line">     $classpath = &quot;&#123;$classname&#125;.php&quot;;</span><br><span class="line">     if(file_exists($classpath))&#123;</span><br><span class="line">         require_once($classpath);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         echo $classpath.&quot; not be found!&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  spl_autoload_register(&quot;myLoad&quot;); </span><br><span class="line">  </span><br><span class="line">  // 当系统找不到相应的类库的时候 调用 myload方法 如果没有规定 自动注册autoload的默认实现函数spl_autoload();</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  $ani = new Animal();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>1，可以按需多次写spl_autoload_register注册加载函数，加载顺序按谁先注册谁先调用。__aotuload由于是全局函数只能定义一次，不够灵活。 自动加载对象方便</p>
<p>2，可以被catch到错误，而__autoload不能。</p>
<p>3，spl_autoload_register注册的加载函数可以按需被spl_autoload_unregister掉</p>
<h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p>运行 Composer 需要 PHP 5.3.2+ 以上版本。</p>
<h4 id="composer的使用"><a href="#composer的使用" class="headerlink" title="composer的使用"></a>composer的使用</h4><ol>
<li><p>在composer.json内包含 require</p>
</li>
<li><p>composer install</p>
</li>
<li><p>require vendor/autoload.php</p>
</li>
</ol>
<p>以上就可以实现自动加载</p>
<h4 id="composer-自动加载原理"><a href="#composer-自动加载原理" class="headerlink" title="composer 自动加载原理"></a>composer 自动加载原理</h4><p>Laravel </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/public/index.php</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Laravel - A PHP Framework For Web Artisans</span><br><span class="line"> *</span><br><span class="line"> * @package  Laravel</span><br><span class="line"> * @author   Taylor Otwell &lt;taylor@laravel.com&gt;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">define(&apos;LARAVEL_START&apos;, microtime(true));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Register The Auto Loader</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Composer provides a convenient, automatically generated class loader for</span><br><span class="line">| our application. We just need to utilize it! We&apos;ll simply require it</span><br><span class="line">| into the script here so that we don&apos;t have to worry about manual</span><br><span class="line">| loading any of our classes later on. It feels great to relax.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">require \_\_DIR__.&apos;/../vendor/autoload.php&apos;; // 发现使用autoload 看到getloader</span><br></pre></td></tr></table></figure>
<p>composer内部代码GetLoader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">vendor/composer/autoload_real.php</span><br><span class="line"></span><br><span class="line">class ComposerAutoloaderInit175720aab51ecef5d6218812498b5793</span><br><span class="line">&#123;</span><br><span class="line">    private static $loader;</span><br><span class="line"></span><br><span class="line">    public static function loadClassLoader($class)</span><br><span class="line">    &#123;</span><br><span class="line">        if (&apos;Composer\Autoload\ClassLoader&apos; === $class) &#123;</span><br><span class="line">            require __DIR__ . &apos;/ClassLoader.php&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        if (null !== self::$loader) &#123;</span><br><span class="line">            return self::$loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spl_autoload_register(array(&apos;ComposerAutoloaderInit175720aab51ecef5d6218812498b5793&apos;, &apos;loadClassLoader&apos;), true, true);</span><br><span class="line">        self::$loader = $loader = new \Composer\Autoload\ClassLoader();</span><br><span class="line">        spl_autoload_unregister(array(&apos;ComposerAutoloaderInit175720aab51ecef5d6218812498b5793&apos;, &apos;loadClassLoader&apos;));</span><br><span class="line"></span><br><span class="line">        $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&apos;HHVM_VERSION&apos;) &amp;&amp; (!function_exists(&apos;zend_loader_file_encoded&apos;) || !zend_loader_file_encoded()); // 根据版本判断使用哪个loader</span><br><span class="line">        if ($useStaticLoader) &#123;</span><br><span class="line">            require_once __DIR__ . &apos;/autoload_static.php&apos;;</span><br><span class="line"></span><br><span class="line">            call_user_func(\Composer\Autoload\ComposerStaticInit175720aab51ecef5d6218812498b5793::getInitializer($loader));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_namespaces.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;set($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_psr4.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $classMap = require __DIR__ . &apos;/autoload_classmap.php&apos;;</span><br><span class="line">            if ($classMap) &#123;</span><br><span class="line">                $loader-&gt;addClassMap($classMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $loader-&gt;register(true);</span><br><span class="line"></span><br><span class="line">        if ($useStaticLoader) &#123;</span><br><span class="line">            $includeFiles = Composer\Autoload\ComposerStaticInit175720aab51ecef5d6218812498b5793::$files;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $includeFiles = require __DIR__ . &apos;/autoload_files.php&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">            composerRequire175720aab51ecef5d6218812498b5793($fileIdentifier, $file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤 ：首先判断PHP版本决定使用Staticloader还是普通的Namespaceloader</p>
<p>加载PSR-0规范的类 方法在ClassLoader内</p>
<p>加载PSR-4规范的类 方法在ClassLoader内 </p>
<p>加载上面两个类就是对ClassLoader内的需要加载的类进行编辑操作</p>
<p>register进行类注册加载 方法在ClassLoader内 调用spl_autoloader_register();</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/autoloader/" data-id="cjgu5ga1600012nfy8tcf4bye" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-4/" class="article-date">
  <time datetime="2018-03-20T09:27:37.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-4/">PHP代码实现3 [函数角度] 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p>标准函数的实现存放在ext/standard扩展目录中。</p>
<h3 id="php函数种类"><a href="#php函数种类" class="headerlink" title="php函数种类"></a>php函数种类</h3><p>Zend engine中的function的存在形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _zend_execute_data &#123;</span><br><span class="line">    //...省略部分代码</span><br><span class="line">    zend_function_state function_state;</span><br><span class="line">    zend_function *fbc; /* Function Being Called */</span><br><span class="line">    //...省略部分代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>zend_function 的存在形式 Union！</p>
<p>联合体的所有成员变量共享内存中的一块内存，在某个时刻只能有一个成员使用这块内存， 并且当使用某一个成员时，其仅能按照它的类型和内存大小修改对应的内存空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zend_function &#123;</span><br><span class="line">    zend_uchar type;    /* 如用户自定义则为 #define ZEND_USER_FUNCTION 2</span><br><span class="line">                            MUST be the first element of this struct! */</span><br><span class="line"> </span><br><span class="line">    struct &#123;</span><br><span class="line">        zend_uchar type;  /* never used */</span><br><span class="line">        char *function_name;    //函数名称</span><br><span class="line">        zend_class_entry *scope; //函数所在的类作用域</span><br><span class="line">        zend_uint fn_flags;     // 作为方法时的访问类型等，如ZEND_ACC_STATIC等  </span><br><span class="line">        union _zend_function *prototype; //函数原型</span><br><span class="line">        zend_uint num_args;     //参数数目</span><br><span class="line">        zend_uint required_num_args; //需要的参数数目</span><br><span class="line">        zend_arg_info *arg_info;  //参数信息指针</span><br><span class="line">        zend_bool pass_rest_by_reference;</span><br><span class="line">        unsigned char return_reference;  //返回值 </span><br><span class="line">    &#125; common;</span><br><span class="line"> </span><br><span class="line">    zend_op_array op_array;   //函数中的操作</span><br><span class="line">    zend_internal_function internal_function;  </span><br><span class="line">&#125; zend_function;</span><br></pre></td></tr></table></figure>
<ul>
<li>在PHP的实现中，即使没有显式的返回， Zend引擎也会“帮你“返回NULL。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$func = &apos;print_r&apos;;</span><br><span class="line">$func(&apos;i am print_r function.&apos;);</span><br><span class="line"></span><br><span class="line">print_r(&apos;i am print_r function.&apos;);</span><br></pre></td></tr></table></figure>
<p>变量函数是DO_FCALL_BY_NAME，而内部函数是DO_FCALL。这在语法解析时就已经决定了</p>
<p>如果不是方法，并且不是动态调用，并且函数名为字符串常量，则其生成的中间代码为ZEND_DO_FCALL。其它情况则为ZEND_DO_FCALL_BY_NAME。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-4/" data-id="cjgu5ga1n000h2nfypy6fij8p" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-3/" class="article-date">
  <time datetime="2018-03-20T05:29:59.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-3/">PHP代码实现2 [从变量和数据的角度] 2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h3 id="常量的数据结构"><a href="#常量的数据结构" class="headerlink" title="常量的数据结构"></a>常量的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_constant &#123;</span><br><span class="line">    zval value; /* zval结构，PHP内部变量的存储结构，在第一小节有说明 */</span><br><span class="line">    int flags;  /* 常量的标记如 CONST_PERSISTENT | CONST_CS */</span><br><span class="line">    char *name; /* 常量名称 */</span><br><span class="line">    uint name_len;  </span><br><span class="line">    int module_number;  /* 模块号 */</span><br><span class="line">&#125; zend_constant;</span><br></pre></td></tr></table></figure>
<p>PHP对于常量的名称在定义时其实是没有所谓的限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;^_^&apos;, &apos;smile&apos;);</span><br><span class="line"> </span><br><span class="line">if (defined(&apos;^_^&apos;)) &#123;</span><br><span class="line">    echo &apos;yes&apos;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    echo &apos;no&apos;;</span><br><span class="line">&#125;</span><br><span class="line">//$var = ^_^;   //语法错误</span><br><span class="line">$var = constant(&quot;^_^&quot;);</span><br></pre></td></tr></table></figure>
<p>通过defined函数测试表示，^_^这个常量已经定义好，这样的常量无法直接调用， 只能使用constant()方法来获取到，否则在语法解析时会报错，因为它不是一个合法的标示符。</p>
<h3 id="常量的等级"><a href="#常量的等级" class="headerlink" title="常量的等级"></a>常量的等级</h3><p>除了CONST_CS标记，常量的flags字段通常还可以用CONST_PERSISTENT和CONST_CT_SUBST。</p>
<p>CONST_PERSISTENT表示这个常量需要持久化。这里的持久化内存申请时的持久化是一个概念， 非持久常量会在请求结束时释放该常量，如果读者还不清楚PHP的生命周期，可以参考， PHP生命周期这一小节，也就是说， [如果是非持久常量，会在RSHUTDOWN阶段就将该常量释放，否则只会在MSHUTDOWN阶段将内存释放]， 在用户空间，也就是用户定义的常量都是非持久化的，通常扩展和内核定义的常量会设置为持久化， 因为如果常量被释放了，而下次请求又需要使用这个常量，该常量就必须在请求时初始化一次， 而对于常量这些不变的量来说就是个没有意义的重复计算。</p>
<p>通过define()函数定义的常量的模块编号都是PHP_USER_CONSTANT，这表示是用户定义的常量。 除此之外我们在平时使用较多的常量：如错误报告级别E_ALL, E_WARNING等常量就有点不同了。 这些是PHP内置定义的常量，他们属于标准常量。</p>
<p>标准常量注册操作： php_module_startup() -&gt; zend_startup() -&gt; zend_register_standard_constants()]</p>
<h3 id="魔术常量-随着代码的位置而改变"><a href="#魔术常量-随着代码的位置而改变" class="headerlink" title="魔术常量 随着代码的位置而改变"></a>魔术常量 随着代码的位置而改变</h3><p>[PHP已经在词法解析时将这些常量换成了对应的值]</p>
<p>几个 PHP 的“魔术常量”<br>名称    说明<br>__LINE__    文件中的当前行号</p>
<p>__FILE__    文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，FILE 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。</p>
<p>__DIR__    文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 dirname(FILE)。除非是根目录，否则 目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）</p>
<p>__FUNCTION__    函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写&gt; 字母的</p>
<p>__CLASS__    类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的</p>
<p>__METHOD__    类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p>
<p>__NAMESPACE__    当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增）</p>
<p>前面有个比较特殊的地方，当func_name不存在时，<strong>FUNCTION</strong>被替换成空字符串， 你可能会想，怎么会有变量名不存在的方法呢，这里并不是匿名方法，匿名方法的function_name 并不是空的，而是:”{closure}”, 有兴趣的读者可以去代码找找在那里给定义了。 </p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>在PHP脚本执行的时候，用户全局变量(在用户空间显式定义的变量)会保存在一个HashTable数据类型的符号表(symbol_table)中， 而我们用得非常多的在全局范围内有效的变量却与这些用户全局变量不同。 例如:$_GET，$_POST，$_SERVER，$_FILES等变量，我们并没有在程序中定义这些变量，并且这些变量也同样保存在符号表中， 从这些表象我们不难得出结论：[PHP是在脚本运行之前就将这些特殊的变量加入到了符号表。] 在请求初始化阶段 RINIT</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="赋值左值存在引用-且左值不等于右值-MMP-这是COW-写时复制啊"><a href="#赋值左值存在引用-且左值不等于右值-MMP-这是COW-写时复制啊" class="headerlink" title="赋值左值存在引用 且左值不等于右值 MMP 这是COW 写时复制啊"></a>赋值左值存在引用 且左值不等于右值 MMP 这是COW 写时复制啊</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line"> </span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line"> </span><br><span class="line">$a = 20;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>此时Zend engine的实现行动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (PZVAL_IS_REF(variable_ptr)) &#123; // 如果is_ref_gc != 0</span><br><span class="line">    if (variable_ptr!=value) &#123; // 且右值 ！= 左值</span><br><span class="line">        zend_uint refcount = Z_REFCOUNT_P(variable_ptr); 存储refcount</span><br><span class="line"> </span><br><span class="line">        garbage = *variable_ptr;  将老值保存</span><br><span class="line">        *variable_ptr = *value;   赋予新的右值</span><br><span class="line">        Z_SET_REFCOUNT_P(variable_ptr, refcount);  设置新的refcount</span><br><span class="line">        Z_SET_ISREF_P(variable_ptr);    设置新的is ref</span><br><span class="line">        if (!is_tmp_var) &#123; </span><br><span class="line">            zendi_zval_copy_ctor(*variable_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        zendi_zval_dtor(garbage);</span><br><span class="line">        return variable_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>COW介绍: 这是一种推迟内存复制带来的内存管理优化，而当变量的值发生变化时，才会进行重新开辟内存空间，这个机制我们称为写时复制机制</p>
<p>EG：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$i = 4;   //内核创建一个zval指针，并且为其以堆的方式开辟空间，让指针指向这个空间，将zval中的成员引用计数置为1，类型标记为整形，并且申请一个zvalue_value指针，同样以堆的方式以其开辟空间,同时将该联合体中的lval赋值为4,并且在symbal_table的hash表中记录变量i和zval指针的映射关系</span><br><span class="line">$j = $i;   //没有在申请内存空间，在zval的成员中引用计数标记为2</span><br><span class="line">$j = 5;   //内核重新创建zval指针，重复下上面的步骤，我就不重复说明了，重点是将旧的zval引用计数标记为1</span><br></pre></td></tr></table></figure>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，左值等于右值"><a href="#赋值的左值不存在引用，左值的引用计数为1，左值等于右值" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，左值等于右值"></a>赋值的左值不存在引用，左值的引用计数为1，左值等于右值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$a = $a; // 引用计数经历了+1 -1的过程</span><br></pre></td></tr></table></figure>
<p>Zend engine的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (Z_DELREF_P(variable_ptr)==0) &#123;  //  引用计数减一操作</span><br><span class="line">        if (!is_tmp_var) &#123;</span><br><span class="line">            if (variable_ptr==value) &#123;</span><br><span class="line">                Z_ADDREF_P(variable_ptr);   //  引用计数加一操作</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，右值存在引用"><a href="#赋值的左值不存在引用，左值的引用计数为1，右值存在引用" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，右值存在引用"></a>赋值的左值不存在引用，左值的引用计数为1，右值存在引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">$c = $a;</span><br></pre></td></tr></table></figure>
<p>这里的$c = $a;的操作就是我们所示的第三种情况。 对于这种情况，ZEND内核直接创建一个新的zval容器，左值的值为右值，并且左值的引用计数为1。 也就是说，这种情形$c不会与$a指向同一个zval。 </p>
<h4 id="赋值的左值不存在引用，左值的引用计数为1，右值不存在引用"><a href="#赋值的左值不存在引用，左值的引用计数为1，右值不存在引用" class="headerlink" title="赋值的左值不存在引用，左值的引用计数为1，右值不存在引用"></a>赋值的左值不存在引用，左值的引用计数为1，右值不存在引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$c = $a;</span><br></pre></td></tr></table></figure>
<p>这时，右值的引用计数加上，一般情况下，会对左值进行垃圾收集操作，将其移入垃圾缓冲池。垃圾缓冲池的功能是在PHP5.3后才有的。 </p>
<h4 id="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"><a href="#情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0" class="headerlink" title="情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0"></a>情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = 10;</span><br><span class="line">$b = $a;</span><br><span class="line">$va = 20;</span><br><span class="line">$vb = &amp;$va;</span><br><span class="line"> </span><br><span class="line">$a = $va;</span><br></pre></td></tr></table></figure>
<p>最后一个操作就是我们的情况五。 使用xdebug看引用计数发现，最终$a变量的引用计数为1，$va变量的引用计数为2，并且$va存在引用。</p>
<h3 id="变量销毁"><a href="#变量销毁" class="headerlink" title="变量销毁"></a>变量销毁</h3><p>unset()是一个语法结构， 根据变量不同出发不同的操作</p>
<p>程序会先获取目标符号表，这个符号表是一个HashTable，然后将我们需要unset掉的变量从这个HashTable中删除。 如果对HashTable的元素删除操作成功，程序还会对EX(CVs)内存储的值进行清空操作。 以缓存机制来解释，在删除原始数据后，程序也会删除相对应的缓存内容，以免用户获取到脏数据。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>对于全局变量，Zend引擎有一个_zend_executor_globals结构，该结构中的symbol_table就是全局符号表， 其中保存了在顶层作用域中的变量。</p>
<p>同样，函数或者对象的方法在被调用时会创建active_symbol_table来保存局部变量。</p>
<p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的active_symbol_table会指向当前_zend_execute_data中的symbol_table。</p>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ol>
<li><p>直接的变量赋值操作</p>
</li>
<li><p>运算式结果对变量的赋值操作</p>
</li>
<li><p>强制类型转换</p>
</li>
</ol>
<ul>
<li>允许进行强制类型转换的类型</li>
</ul>
<p>(int), (integer) 转换为整型</p>
<p>(bool), (boolean) 转换为布尔类型</p>
<p>(float), (double) 转换为浮点类型</p>
<p>(string) 转换为字符串</p>
<p>(array) 转换为数组</p>
<p>(object) 转换为对象</p>
<p>(unset) 转换为NULL </p>
<p>（unset）\$a(仅仅是类型转换为了null) != unset($a)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-3/" data-id="cjgu5ga1m000f2nfy23sehni6" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-php-code-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-2/" class="article-date">
  <time datetime="2018-03-20T03:19:22.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/20/php-code-2/">PHP代码实现2 [从变量和数据的角度] 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&lt;编译&gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。</p>
<p>2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化</p>
<p>3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感知。</p>
<h1 id="PHP-8种变量类型"><a href="#PHP-8种变量类型" class="headerlink" title="PHP 8种变量类型"></a>PHP 8种变量类型</h1><p>String Int float Boolean Null Resource Object array</p>
<p>在官方的PHP实现内部，所有变量使用同一种数据结构(zval)来保存，而这个结构同时表示PHP中的各种数据类型。 它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。</p>
<h2 id="PHP变量存储结构"><a href="#PHP变量存储结构" class="headerlink" title="PHP变量存储结构"></a>PHP变量存储结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct zval;</span><br><span class="line">...</span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">    /* Variable information */</span><br><span class="line">    zvalue_value value;     /* value */ 变量值</span><br><span class="line">    zend_uint refcount__gc; // 引用计数 GC的时候用 默认1</span><br><span class="line">    zend_uchar type;    /* active type */ 变量类型</span><br><span class="line">    zend_uchar is_ref__gc; // 是否为引用 默认0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：在PHP5.3之后引入了新垃圾收集机制 则refcount -&gt; refcount_gc is_ref -&gt; is_ref_gc</p>
<p>【注意 变量的值存在了zvalue_value这个struct中，那么也就是其的内存占用很玄学，也就是是用union 来巧妙的避开多内存占用】</p>
<p>type:IS_NULL、IS_BOOL、IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE</p>
<h2 id="PHP变量的值的存储"><a href="#PHP变量的值的存储" class="headerlink" title="PHP变量的值的存储"></a>PHP变量的值的存储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;                  /* long value */</span><br><span class="line">    double dval;                /* double value */</span><br><span class="line">    struct &#123;						/*string value*/</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;              /* hash table value */</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>这里使用联合体而不是用结构体是出于空间利用率的考虑，因为一个变量同时只能属于一种类型。 如果使用结构体的话将会不必要的浪费空间，而PHP中的所有逻辑都围绕变量来进行的，这样的话， 内存浪费将是十分大的。这种做法成本小但收益非常大。</p>
<p>注意到字符串value中加入了int的 len， 这和MyIsam存储结构存储长度的原理是相同的，因为获取到字符串长度的时间复杂度是O(n),字符串在PHP操作中很频繁，为了节约时间开销，直接存储进来。是一种空间换时间的做法</p>
<p>【哈希相关】</p>
<p>通过合理设计的哈希函数，我们就能将key映射到合适的范围，因为我们的key空间可以很大(例如字符串key)， 在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况， 这就是我们所说的出现了冲突。 目前解决hash冲突的方法主要有两种：链接法和开放寻址法。</p>
<ul>
<li>链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。 所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表， 这样的话操作链表的时间复杂度则成了O(n)，这样哈希表的性能优势就没有了， 所以选择一个合适的哈希函数是最为关键的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket /** 采用链接法解决哈希冲突的HashTable结构 最坏情况 O(n) **/</span><br><span class="line">&#123;</span><br><span class="line">    char *key;</span><br><span class="line">    void *value;</span><br><span class="line">    struct _Bucket *next;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"> </span><br><span class="line">typedef struct _HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int elem_num;</span><br><span class="line">    Bucket** buckets;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<ul>
<li>键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。</li>
<li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。</li>
</ul>
<p>hash_Insert函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int hash_insert(HashTable *ht, char *key, void *value)</span><br><span class="line">&#123;</span><br><span class="line">    // check if we need to resize the hashtable</span><br><span class="line">    resize_hash_table_if_needed(ht);</span><br><span class="line"> </span><br><span class="line">    int index = HASH_INDEX(ht, key);</span><br><span class="line"> </span><br><span class="line">    Bucket *org_bucket = ht-&gt;buckets[index]; // 获得计算出来的index所在的bucket</span><br><span class="line">    Bucket *tmp_bucket = org_bucket;</span><br><span class="line"> </span><br><span class="line">    // check if the key-value exits already</span><br><span class="line">    while(tmp_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(key, tmp_bucket-&gt;key) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(&quot;[update]\tkey: %s\n&quot;, key);</span><br><span class="line">            tmp_bucket-&gt;value = value;</span><br><span class="line"> </span><br><span class="line">            return SUCCESS; // 查看当前的key对应的value是否已经存在了，value是不允许重复的</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tmp_bucket = tmp_bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Bucket *bucket = (Bucket *)malloc(sizeof(Bucket)); 分配新的bucket的地址</span><br><span class="line"> </span><br><span class="line">    bucket-&gt;key   = key;</span><br><span class="line">    bucket-&gt;value = value;</span><br><span class="line">    bucket-&gt;next  = NULL;  进行相关bucket的赋值</span><br><span class="line"> </span><br><span class="line">    ht-&gt;elem_num += 1;    HashTable计数增加</span><br><span class="line"> </span><br><span class="line">    if(org_bucket != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_MSG(&quot;[collision]\tindex:%d key:%s\n&quot;, index, key); 出现冲突 </span><br><span class="line">        bucket-&gt;next = org_bucket; 将新的bucket放在index的第一位 后面进行顺延</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ht-&gt;buckets[index]= bucket; </span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[insert]\tindex:%d key:%s\tht(num:%d)\n&quot;,</span><br><span class="line">        index, key, ht-&gt;elem_num);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int hash_resize(HashTable *ht)</span><br><span class="line">&#123;</span><br><span class="line">    // double the size</span><br><span class="line">    int org_size = ht-&gt;size;</span><br><span class="line">    ht-&gt;size = ht-&gt;size * 2;</span><br><span class="line">    ht-&gt;elem_num = 0; //后续重新插入，因为Double size之后 之前的冲突有可能被解开，所以重新Insert</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize]\torg size: %i\tnew size: %i\n&quot;, org_size, ht-&gt;size);</span><br><span class="line"> </span><br><span class="line">    Bucket **buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *));</span><br><span class="line"> </span><br><span class="line">    Bucket **org_buckets = ht-&gt;buckets; 获取老的buckets</span><br><span class="line">    ht-&gt;buckets = buckets;// 新的table置为空</span><br><span class="line"> </span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0; i &lt; org_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Bucket *cur = org_buckets[i];</span><br><span class="line">        Bucket *tmp;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            // rehash: insert again</span><br><span class="line">            hash_insert(ht, cur-&gt;key, cur-&gt;value);</span><br><span class="line"> </span><br><span class="line">            // free the org bucket, but not the element</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            free(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(org_buckets);</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize] done\n&quot;);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组是PHP中最常用，也是最强大变量类型，它可以存储其他类型的数据，而且提供各种内置操作函数。数组的存储相对于其他变量要复杂一些， 数组的值存储在zvalue_value.ht字段中，它是一个HashTable类型的数据。 PHP的数组使用哈希表来存储关联数据。哈希表是一种高效的键值对存储结构。PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。 PHP所有的工作都由哈希表实现，在下节HashTable中将进行哈希表基本概念的介绍以及PHP的哈希表实现。（WOC PHP竟然用HashTable存储array，O(1)!）</p>
<p>对象的存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_object_value &#123;</span><br><span class="line">    zend_object_handle handle;  //  unsigned int类型，EG(objects_store).object_buckets的索引</span><br><span class="line">    zend_object_handlers *handlers;</span><br><span class="line">&#125; zend_object_value;</span><br></pre></td></tr></table></figure>
<p>PHP的对象只有在运行时才会被创建，前面的章节介绍了EG宏，这是一个全局结构体用于保存在运行时的数据。 其中就包括了用来保存所有被创建的对象的对象池</p>
<p>而object对象值内容的zend_object_handle域就是当前 对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry，将在第五章作详细介绍</p>
<h3 id="PHP-HashTable实现"><a href="#PHP-HashTable实现" class="headerlink" title="PHP HashTable实现"></a>PHP HashTable实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _hashtable &#123; </span><br><span class="line">    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。</span><br><span class="line">    uint nTableMask;        // nTableSize-1 ， 索引取值的优化</span><br><span class="line">    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 </span><br><span class="line">    ulong nNextFreeElement; // 下一个数字索引的位置</span><br><span class="line">    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）</span><br><span class="line">    Bucket *pListHead;          // 存储数组头元素指针</span><br><span class="line">    Bucket *pListTail;          // 存储数组尾元素指针</span><br><span class="line">    Bucket **arBuckets;         // 存储hash数组</span><br><span class="line">    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放</span><br><span class="line">    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。</span><br><span class="line">    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）</span><br><span class="line">    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次</span><br><span class="line">#if ZEND_DEBUG</span><br><span class="line">    int inconsistent;</span><br><span class="line">#endif</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>PS：mask的作用就是将哈希值映射到槽位所能存储的索引范围内。 例如：某个key的索引值是21， 哈希表的大小为8，则mask为7，则求与时的二进制表示为： 10101 &amp; 111 = 101 也就是十进制的5。 因为2的整数次方-1的二进制比较特殊：后面N位的值都是1，这样比较容易能将值进行映射， 如果是普通数字进行了二进制与之后会影响哈希值的结果。那么哈希函数计算的值的平均分布就可能出现影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct bucket &#123;</span><br><span class="line">    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值</span><br><span class="line">    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0</span><br><span class="line">    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr</span><br><span class="line">    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值</span><br><span class="line">    struct bucket *pListNext;   // 整个hash表的下一元素</span><br><span class="line">    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素</span><br><span class="line">    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素</span><br><span class="line">    struct bucket *pLast;       // 同一个哈希bucket的上一个元素</span><br><span class="line">    // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体</span><br><span class="line">    char arKey[1];              // 是变长结构体 在插入的时候进行单独申请空间就可以</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>PS：如上面各字段的注释。h字段保存哈希表key哈希后的值。这里保存的哈希值而不是在哈希表中的索引值， 这是因为索引值和哈希表的容量有直接关系，如果哈希表扩容了，那么这些索引还得重新进行哈希在进行索引映射， 这也是一种优化手段。</p>
<p>在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。 所以在PHP中例如’10’，’11’这类的字符索引和数字索引10， 11没有区别。</p>
<p>HashTable的操作接口常见：</p>
<ul>
<li>初始化操作，例如zend_hash_init()函数，用于初始化哈希表接口，分配空间等。</li>
<li>查找，插入，删除和更新操作接口，这是比较常规的操作。</li>
<li>迭代和循环，这类的接口用于循环对哈希表进行操作。</li>
<li>复制，排序，倒置和销毁等操作。</li>
</ul>
<p>PS：在PHP中不管是对数组的添加操作（zend_hash_add），还是对数组的更新操作（zend_hash_update）， 其最终都是调用_zend_hash_add_or_update函数完成，这在面向对象编程中相当于两个公有方法和一个公共的私有方法的结构， 以实现一定程度上的代码复用。</p>
<h3 id="PHP-List链表实现"><a href="#PHP-List链表实现" class="headerlink" title="PHP List链表实现"></a>PHP List链表实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_llist_element &#123;</span><br><span class="line">    struct _zend_llist_element *next;</span><br><span class="line">    struct _zend_llist_element *prev;</span><br><span class="line">    char data[1]; /* Needs to always be last in the struct */</span><br><span class="line">&#125; zend_llist_element;</span><br><span class="line"> </span><br><span class="line">typedef struct _zend_llist &#123;</span><br><span class="line">    zend_llist_element *head;</span><br><span class="line">    zend_llist_element *tail;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t size;</span><br><span class="line">    llist_dtor_func_t dtor;</span><br><span class="line">    unsigned char persistent;</span><br><span class="line">    zend_llist_element *traverse_ptr;</span><br><span class="line">&#125; zend_llist;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void zend_llist_add_element(zend_llist *l, void *element) // List插入操作</span><br><span class="line">&#123;</span><br><span class="line">    zend_llist_element *tmp = pemalloc(sizeof(zend_llist_element)+l-&gt;size-1, l-&gt;persistent);</span><br><span class="line"> </span><br><span class="line">    tmp-&gt;prev = l-&gt;tail;</span><br><span class="line">    tmp-&gt;next = NULL;</span><br><span class="line">    if (l-&gt;tail) &#123;</span><br><span class="line">        l-&gt;tail-&gt;next = tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        l-&gt;head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;tail = tmp;</span><br><span class="line">    memcpy(tmp-&gt;data, element, l-&gt;size);</span><br><span class="line"> </span><br><span class="line">    ++l-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：PHP中很多的函数都会有*_ex()以及不带ex两个版本的函数，这主要是为了方便使用， 和上面的代码一样，ex版本的通常是一个功能较全或者可选参数较多的版本， 而在代码中很多地方默认的参数值都一样，为了方便使用，再封装一个普通版本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-2/" data-id="cjgu5ga1l000e2nfyik2syp4b" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">次へ &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">アーカイブ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">5月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">3月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近の投稿</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/06/weekend5/">4.21-5.6周记</a>
          </li>
        
          <li>
            <a href="/2018/04/20/weekend4/">4.7-4.20周记</a>
          </li>
        
          <li>
            <a href="/2018/04/06/weekend3/">Weekend Log 4.6</a>
          </li>
        
          <li>
            <a href="/2018/03/30/weekend2/">3.30一周拾遗</a>
          </li>
        
          <li>
            <a href="/2018/03/25/weekend1/">3.25周 一周拾遗</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 GuoQingZhe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>