<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>PHP代码实现2 [从变量和数据的角度] 1 | GTX Ultimate</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="数据类型1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&amp;lt;编译&amp;gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。 2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化 3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP代码实现2 [从变量和数据的角度] 1">
<meta property="og:url" content="http://yoursite.com/2018/03/20/php-code-2/index.html">
<meta property="og:site_name" content="GTX Ultimate">
<meta property="og:description" content="数据类型1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&amp;lt;编译&amp;gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。 2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化 3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感">
<meta property="og:locale" content="ja">
<meta property="og:updated_time" content="2018-03-20T05:29:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP代码实现2 [从变量和数据的角度] 1">
<meta name="twitter:description" content="数据类型1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&amp;lt;编译&amp;gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。 2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化 3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感">
  
    <link rel="alternate" href="/atom.xml" title="GTX Ultimate" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">GTX Ultimate</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Force Or Blood</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-php-code-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/20/php-code-2/" class="article-date">
  <time datetime="2018-03-20T03:19:22.000Z" itemprop="datePublished">2018-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      PHP代码实现2 [从变量和数据的角度] 1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>1.静态类型语言，比如：C/Java等，在静态语言类型中，类型的检查是在&lt;编译&gt;(compile-time)确定的， 也就是说在运行时变量的类型是不会发生变化的。</p>
<p>2.动态语言类型，比如：PHP，python等各种脚本语言，这类语言中的类型是在[运行时]确定的， 那么也就是说类型通常可以在运行时发生变化</p>
<p>3.无类型语言，比如：汇编语言，汇编语言操作的是底层存储，他们对类型毫无感知。</p>
<h1 id="PHP-8种变量类型"><a href="#PHP-8种变量类型" class="headerlink" title="PHP 8种变量类型"></a>PHP 8种变量类型</h1><p>String Int float Boolean Null Resource Object array</p>
<p>在官方的PHP实现内部，所有变量使用同一种数据结构(zval)来保存，而这个结构同时表示PHP中的各种数据类型。 它不仅仅包含变量的值，也包含变量的类型。这就是PHP弱类型的核心。</p>
<h2 id="PHP变量存储结构"><a href="#PHP变量存储结构" class="headerlink" title="PHP变量存储结构"></a>PHP变量存储结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct zval;</span><br><span class="line">...</span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">    /* Variable information */</span><br><span class="line">    zvalue_value value;     /* value */ 变量值</span><br><span class="line">    zend_uint refcount__gc; // 引用计数 GC的时候用 默认1</span><br><span class="line">    zend_uchar type;    /* active type */ 变量类型</span><br><span class="line">    zend_uchar is_ref__gc; // 是否为引用 默认0</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PS：在PHP5.3之后引入了新垃圾收集机制 则refcount -&gt; refcount_gc is_ref -&gt; is_ref_gc</p>
<p>【注意 变量的值存在了zvalue_value这个struct中，那么也就是其的内存占用很玄学，也就是是用union 来巧妙的避开多内存占用】</p>
<p>type:IS_NULL、IS_BOOL、IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE</p>
<h2 id="PHP变量的值的存储"><a href="#PHP变量的值的存储" class="headerlink" title="PHP变量的值的存储"></a>PHP变量的值的存储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;                  /* long value */</span><br><span class="line">    double dval;                /* double value */</span><br><span class="line">    struct &#123;						/*string value*/</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;              /* hash table value */</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>这里使用联合体而不是用结构体是出于空间利用率的考虑，因为一个变量同时只能属于一种类型。 如果使用结构体的话将会不必要的浪费空间，而PHP中的所有逻辑都围绕变量来进行的，这样的话， 内存浪费将是十分大的。这种做法成本小但收益非常大。</p>
<p>注意到字符串value中加入了int的 len， 这和MyIsam存储结构存储长度的原理是相同的，因为获取到字符串长度的时间复杂度是O(n),字符串在PHP操作中很频繁，为了节约时间开销，直接存储进来。是一种空间换时间的做法</p>
<p>【哈希相关】</p>
<p>通过合理设计的哈希函数，我们就能将key映射到合适的范围，因为我们的key空间可以很大(例如字符串key)， 在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况， 这就是我们所说的出现了冲突。 目前解决hash冲突的方法主要有两种：链接法和开放寻址法。</p>
<ul>
<li>链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到一个槽中的时候使用链表来保存这些值。 所以使用链接法是在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表， 这样的话操作链表的时间复杂度则成了O(n)，这样哈希表的性能优势就没有了， 所以选择一个合适的哈希函数是最为关键的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _Bucket /** 采用链接法解决哈希冲突的HashTable结构 最坏情况 O(n) **/</span><br><span class="line">&#123;</span><br><span class="line">    char *key;</span><br><span class="line">    void *value;</span><br><span class="line">    struct _Bucket *next;</span><br><span class="line">&#125; Bucket;</span><br><span class="line"> </span><br><span class="line">typedef struct _HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int size;</span><br><span class="line">    int elem_num;</span><br><span class="line">    Bucket** buckets;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<ul>
<li>键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。</li>
<li>槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。</li>
<li>哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。</li>
<li>哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。</li>
</ul>
<p>hash_Insert函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int hash_insert(HashTable *ht, char *key, void *value)</span><br><span class="line">&#123;</span><br><span class="line">    // check if we need to resize the hashtable</span><br><span class="line">    resize_hash_table_if_needed(ht);</span><br><span class="line"> </span><br><span class="line">    int index = HASH_INDEX(ht, key);</span><br><span class="line"> </span><br><span class="line">    Bucket *org_bucket = ht-&gt;buckets[index]; // 获得计算出来的index所在的bucket</span><br><span class="line">    Bucket *tmp_bucket = org_bucket;</span><br><span class="line"> </span><br><span class="line">    // check if the key-value exits already</span><br><span class="line">    while(tmp_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        if(strcmp(key, tmp_bucket-&gt;key) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG_MSG(&quot;[update]\tkey: %s\n&quot;, key);</span><br><span class="line">            tmp_bucket-&gt;value = value;</span><br><span class="line"> </span><br><span class="line">            return SUCCESS; // 查看当前的key对应的value是否已经存在了，value是不允许重复的</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        tmp_bucket = tmp_bucket-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Bucket *bucket = (Bucket *)malloc(sizeof(Bucket)); 分配新的bucket的地址</span><br><span class="line"> </span><br><span class="line">    bucket-&gt;key   = key;</span><br><span class="line">    bucket-&gt;value = value;</span><br><span class="line">    bucket-&gt;next  = NULL;  进行相关bucket的赋值</span><br><span class="line"> </span><br><span class="line">    ht-&gt;elem_num += 1;    HashTable计数增加</span><br><span class="line"> </span><br><span class="line">    if(org_bucket != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_MSG(&quot;[collision]\tindex:%d key:%s\n&quot;, index, key); 出现冲突 </span><br><span class="line">        bucket-&gt;next = org_bucket; 将新的bucket放在index的第一位 后面进行顺延</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ht-&gt;buckets[index]= bucket; </span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[insert]\tindex:%d key:%s\tht(num:%d)\n&quot;,</span><br><span class="line">        index, key, ht-&gt;elem_num);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static int hash_resize(HashTable *ht)</span><br><span class="line">&#123;</span><br><span class="line">    // double the size</span><br><span class="line">    int org_size = ht-&gt;size;</span><br><span class="line">    ht-&gt;size = ht-&gt;size * 2;</span><br><span class="line">    ht-&gt;elem_num = 0; //后续重新插入，因为Double size之后 之前的冲突有可能被解开，所以重新Insert</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize]\torg size: %i\tnew size: %i\n&quot;, org_size, ht-&gt;size);</span><br><span class="line"> </span><br><span class="line">    Bucket **buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *));</span><br><span class="line"> </span><br><span class="line">    Bucket **org_buckets = ht-&gt;buckets; 获取老的buckets</span><br><span class="line">    ht-&gt;buckets = buckets;// 新的table置为空</span><br><span class="line"> </span><br><span class="line">    int i = 0;</span><br><span class="line">    for(i=0; i &lt; org_size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Bucket *cur = org_buckets[i];</span><br><span class="line">        Bucket *tmp;</span><br><span class="line">        while(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            // rehash: insert again</span><br><span class="line">            hash_insert(ht, cur-&gt;key, cur-&gt;value);</span><br><span class="line"> </span><br><span class="line">            // free the org bucket, but not the element</span><br><span class="line">            tmp = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            free(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(org_buckets);</span><br><span class="line"> </span><br><span class="line">    LOG_MSG(&quot;[resize] done\n&quot;);</span><br><span class="line"> </span><br><span class="line">    return SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组是PHP中最常用，也是最强大变量类型，它可以存储其他类型的数据，而且提供各种内置操作函数。数组的存储相对于其他变量要复杂一些， 数组的值存储在zvalue_value.ht字段中，它是一个HashTable类型的数据。 PHP的数组使用哈希表来存储关联数据。哈希表是一种高效的键值对存储结构。PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。 PHP所有的工作都由哈希表实现，在下节HashTable中将进行哈希表基本概念的介绍以及PHP的哈希表实现。（WOC PHP竟然用HashTable存储array，O(1)!）</p>
<p>对象的存储：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_object_value &#123;</span><br><span class="line">    zend_object_handle handle;  //  unsigned int类型，EG(objects_store).object_buckets的索引</span><br><span class="line">    zend_object_handlers *handlers;</span><br><span class="line">&#125; zend_object_value;</span><br></pre></td></tr></table></figure>
<p>PHP的对象只有在运行时才会被创建，前面的章节介绍了EG宏，这是一个全局结构体用于保存在运行时的数据。 其中就包括了用来保存所有被创建的对象的对象池</p>
<p>而object对象值内容的zend_object_handle域就是当前 对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry，将在第五章作详细介绍</p>
<h3 id="PHP-HashTable实现"><a href="#PHP-HashTable实现" class="headerlink" title="PHP HashTable实现"></a>PHP HashTable实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _hashtable &#123; </span><br><span class="line">    uint nTableSize;        // hash Bucket的大小，最小为8，以2x增长。</span><br><span class="line">    uint nTableMask;        // nTableSize-1 ， 索引取值的优化</span><br><span class="line">    uint nNumOfElements;    // hash Bucket中当前存在的元素个数，count()函数会直接返回此值 </span><br><span class="line">    ulong nNextFreeElement; // 下一个数字索引的位置</span><br><span class="line">    Bucket *pInternalPointer;   // 当前遍历的指针（foreach比for快的原因之一）</span><br><span class="line">    Bucket *pListHead;          // 存储数组头元素指针</span><br><span class="line">    Bucket *pListTail;          // 存储数组尾元素指针</span><br><span class="line">    Bucket **arBuckets;         // 存储hash数组</span><br><span class="line">    dtor_func_t pDestructor;    // 在删除元素时执行的回调函数，用于资源的释放</span><br><span class="line">    zend_bool persistent;       //指出了Bucket内存分配的方式。如果persisient为TRUE，则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。</span><br><span class="line">    unsigned char nApplyCount; // 标记当前hash Bucket被递归访问的次数（防止多次递归）</span><br><span class="line">    zend_bool bApplyProtection;// 标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次</span><br><span class="line">#if ZEND_DEBUG</span><br><span class="line">    int inconsistent;</span><br><span class="line">#endif</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>PS：mask的作用就是将哈希值映射到槽位所能存储的索引范围内。 例如：某个key的索引值是21， 哈希表的大小为8，则mask为7，则求与时的二进制表示为： 10101 &amp; 111 = 101 也就是十进制的5。 因为2的整数次方-1的二进制比较特殊：后面N位的值都是1，这样比较容易能将值进行映射， 如果是普通数字进行了二进制与之后会影响哈希值的结果。那么哈希函数计算的值的平均分布就可能出现影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct bucket &#123;</span><br><span class="line">    ulong h;            // 对char *key进行hash后的值，或者是用户指定的数字索引值</span><br><span class="line">    uint nKeyLength;    // hash关键字的长度，如果数组索引为数字，此值为0</span><br><span class="line">    void *pData;        // 指向value，一般是用户数据的副本，如果是指针数据，则指向pDataPtr</span><br><span class="line">    void *pDataPtr;     //如果是指针数据，此值会指向真正的value，同时上面pData会指向此值</span><br><span class="line">    struct bucket *pListNext;   // 整个hash表的下一元素</span><br><span class="line">    struct bucket *pListLast;   // 整个哈希表该元素的上一个元素</span><br><span class="line">    struct bucket *pNext;       // 存放在同一个hash Bucket内的下一个元素</span><br><span class="line">    struct bucket *pLast;       // 同一个哈希bucket的上一个元素</span><br><span class="line">    // 保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体</span><br><span class="line">    char arKey[1];              // 是变长结构体 在插入的时候进行单独申请空间就可以</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>PS：如上面各字段的注释。h字段保存哈希表key哈希后的值。这里保存的哈希值而不是在哈希表中的索引值， 这是因为索引值和哈希表的容量有直接关系，如果哈希表扩容了，那么这些索引还得重新进行哈希在进行索引映射， 这也是一种优化手段。</p>
<p>在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。 所以在PHP中例如’10’，’11’这类的字符索引和数字索引10， 11没有区别。</p>
<p>HashTable的操作接口常见：</p>
<ul>
<li>初始化操作，例如zend_hash_init()函数，用于初始化哈希表接口，分配空间等。</li>
<li>查找，插入，删除和更新操作接口，这是比较常规的操作。</li>
<li>迭代和循环，这类的接口用于循环对哈希表进行操作。</li>
<li>复制，排序，倒置和销毁等操作。</li>
</ul>
<p>PS：在PHP中不管是对数组的添加操作（zend_hash_add），还是对数组的更新操作（zend_hash_update）， 其最终都是调用_zend_hash_add_or_update函数完成，这在面向对象编程中相当于两个公有方法和一个公共的私有方法的结构， 以实现一定程度上的代码复用。</p>
<h3 id="PHP-List链表实现"><a href="#PHP-List链表实现" class="headerlink" title="PHP List链表实现"></a>PHP List链表实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_llist_element &#123;</span><br><span class="line">    struct _zend_llist_element *next;</span><br><span class="line">    struct _zend_llist_element *prev;</span><br><span class="line">    char data[1]; /* Needs to always be last in the struct */</span><br><span class="line">&#125; zend_llist_element;</span><br><span class="line"> </span><br><span class="line">typedef struct _zend_llist &#123;</span><br><span class="line">    zend_llist_element *head;</span><br><span class="line">    zend_llist_element *tail;</span><br><span class="line">    size_t count;</span><br><span class="line">    size_t size;</span><br><span class="line">    llist_dtor_func_t dtor;</span><br><span class="line">    unsigned char persistent;</span><br><span class="line">    zend_llist_element *traverse_ptr;</span><br><span class="line">&#125; zend_llist;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ZEND_API void zend_llist_add_element(zend_llist *l, void *element) // List插入操作</span><br><span class="line">&#123;</span><br><span class="line">    zend_llist_element *tmp = pemalloc(sizeof(zend_llist_element)+l-&gt;size-1, l-&gt;persistent);</span><br><span class="line"> </span><br><span class="line">    tmp-&gt;prev = l-&gt;tail;</span><br><span class="line">    tmp-&gt;next = NULL;</span><br><span class="line">    if (l-&gt;tail) &#123;</span><br><span class="line">        l-&gt;tail-&gt;next = tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        l-&gt;head = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;tail = tmp;</span><br><span class="line">    memcpy(tmp-&gt;data, element, l-&gt;size);</span><br><span class="line"> </span><br><span class="line">    ++l-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：PHP中很多的函数都会有*_ex()以及不带ex两个版本的函数，这主要是为了方便使用， 和上面的代码一样，ex版本的通常是一个功能较全或者可选参数较多的版本， 而在代码中很多地方默认的参数值都一样，为了方便使用，再封装一个普通版本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/20/php-code-2/" data-id="cjfo0va9e000ejpfyj480pkuk" class="article-share-link">共有</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/20/php-code-3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">次の記事</strong>
      <div class="article-nav-title">
        
          PHP代码实现2 [从变量和数据的角度] 2
        
      </div>
    </a>
  
  
    <a href="/2018/03/20/php-code-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前の記事</strong>
      <div class="article-nav-title">PHP代码实现 1 [宏观角度]</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">アーカイブ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">4月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">3月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近の投稿</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/06/weekend3/">Weekend Log 4.6</a>
          </li>
        
          <li>
            <a href="/2018/03/30/weekend2/">3.30一周拾遗</a>
          </li>
        
          <li>
            <a href="/2018/03/25/weekend1/">3.25周 一周拾遗</a>
          </li>
        
          <li>
            <a href="/2018/03/20/mysql-acid/">MySQL 事务处理</a>
          </li>
        
          <li>
            <a href="/2018/03/20/autoloader/">自动加载以及Composer的实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 GuoQingZhe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>